= Лекция хуй знает какая. 27 марта 2025

== Свойства класса языков

/ Класс языков: --- это множество языков.

*Пример*: регулярные языки.
// ты меня видишь? тут ошибка в моменте была
// окей

- Классы языков имеют два вида важных свойств:
1. Разрешимые свойства
2. Свойства замкнутости

// всё, отлично

== Представление языков

Каждый раз, когда нам дан язык, мы будем понимать, что он дан в своей формальной форме.


*Пример:* (неформальный): логическое или описательное утверждение
// TODO: вроде было, но мб доделать надо

== Проблема принадлежности строки языку
- Нашей первой разрешимой проблемой для регулярных языков будет отвте на вопрос: "находится ли строка $w$ в ...


- Смодеируем работу $A$ на последовательности входных символов $w$.

Так, если язык описывается конечным автоматом, он будет представлять только те цепочки, которые принадлежат его языку. Так что проблема объединения регулярных языков в классы вполне разрешима.

Вторая проблема тоже проста, но требует некоторого обоснования.

// TODO: да, было, я переписываю сознательно --- чтобы на сессии сделать слияние и залатать дыры в основном конспекте

== Проблема пустоты

Есть регулярный язык, который представлен конечным автоматом. Является ли этот язык (содержит ли он хотя бы одну строку, хотя бы пустую?)? Разрешается следующим образом.

- Для данного регулярного языка определить, содержит ли он зотя бы одну строку?
- Пусть представлением языка является КДА.
- Вычислим множество состояний достижимых из начального
- Если хотя бы одно из конечных состояний достижимо, то ответ "да", иначе --- "нет".
- *Проблема пустоты* для регулярных языков _разрешима_

Раз существует путь из начальной вершини в конечную, то метки этого пути и есть слово. Это слово и принадлежит языку, который допускается данным автоматом.

== Проблема бесконечности

/* HACK: была разрешена великим американским учёным Таносом */

Дан регулярный язык, является ли он бесконечным? Возьмём для представления конечный детерменированный автомат.

- Рассмотрим КДА для языка
- *Ключевая идея*: если КДА имеет $n$ состояний и язык содержит какую либо строку длины $n$ или более, то язык бесконечный
- В противном случае, язык, безусловно, конечный.
 - Можно ограничиться строками длины $n$ и меньше.
	- Очевидно, что если КДА не принимает ни одной строки длиной равной или большей, чем $n$, то он принимает только конечное количество строк

// HACK:
// Ты грубо говоря как в мердж сортире делишь массив до множества единичных массивов, а потом собираешь в отсортированном порядке

// HACK: если бы в хоккее шайба была белой, то её не били бы.
// аххаахаха
Докозательство --- (2)

#image("imgs/024.png")


тогда $x y^i z$ является языком для всех $i gt.eq 0$.

Т.к. у нее естть $epsilon$, мы имеем бесконечное число строк в $L$


== Бесконечность --- продолжение

- Пока мы не имеем алгоритма.
- Существует бесконечное число строк длины $> n$, и мы не можем проверить их все.
- Вторая ключевая идея: если существет строка длины $gt.eq n$ ($n$ --- числу состояний в $L$) // TODO: дописать


// HACK: Вчера на вокзале гипнотизер и местная цыганка два часа передавали друг другу кошельки, пока их не забрал патруль полиции.

== Докозательство второй ключевой идеи

Вспомним:
- $y$ -- это первый цикл в пути


=== Завершение доказательства алгоритма

- Для доказательства бесконечности регулярного языка построим для него КДА. Пусть он имеет $n$ состяний
- Протестируем на принадлежность языку всех строк длины между $n$ и $2 n - 1$
	- Если какая-либо из них принимается, то язык бесконечен, иначе --- конечен
- Ужастный алгоритм. Если мы имеем $k$ входных символов и $n$ состояний, то число строк для проверки составит $k^(2n)$
- *Лучшее*: найти циклы между начальным и конечным состояниями для этого алгоритм сложности порядка $k n$

Пример, показывающиий существенность замечания:

#image("imgs/025.png")



== Поиск циклов
+ Исключим состояния, недостижимые из начального состояния.
+ Устраним состояния, из которых не достигаются конечные состояния.
+ Проверим наличие циклов в оставшемся графе переходов.


== Поиск циклов --- (2)
// TODO: пиздец

== Лемма о накачке
- Мы, почти случайно, доказалит утверждение, которое полезно для доказательства того, что определенные языки не являются регулярными
- Назовём соответствующее утверждение *леммой о накачке для регулярных языков*
// ты без превью работаешь?
// я тогда не буду картинки комментировать
// ок

// HACK: НАКАЧКА ЯЗЫКОВ СИНТОООООООООООООООООООООООООООООООООООООООООООООЛ
// хотел придумать шутку про говновоз, но че то не придумал
// злые питерские языки нашептали мне, что их каждый день чем-то накачивают

== Формулировка леммы о накачке 
*Лемма* Для каждого регулярного языка $L$ существует целое $n$ (число состояний автомат), такое что  для каждой строки $w$ из $L$ длины $gt.eq n$ мы можем записать ее как $w = underbrace(x y z, #[метки вдоль \ первого цикла пути, \ помеченного w]) $ так, что:

1. $| x y | <= n $
2. $| y | > 0 $
3. $ forall i >= 0 space x y z in L$

Итак, если язык регулярный то у него есть такое свойство: строку длиною больше, чем $n$, можно представить в виде $x y z$, то мы можем накачать язык новыми словами.

=== Пример: Применение леммы о накачке

та лемма иногда позволяет устанавливать #text(weight: "bold",  "не")регулярность языков.

- Рассмотрим язык ${0^k 1^k | k gt.eq 1}$. Мы говорили,что он не регулярный.
- Предположим, что это так. Тогда для данного языка должно существовать ассоциированное с леммой число $n$
- Пусть $w = 0^n 1^n$. Мы можем записать $w = x y z$, где $|x y| lt.eq n$, т.е. $x$ и $y$ состоят из $0$-ей, и $y eq.not epsilon$
- Но тогда $x y y z$ тоже должна быть $L$, и эта трока имет нулей больше, чем единиц!

=== Проблема: Эквивалентсность
- По данным регулярным языкам $L$ и $M$ определить $L = M$?
- Алгоритм доказательства существования разрешающей процедуры базируется на построении специального КДА --- *произведения* автоматов для $L$ и $M$.
	- *произведения* автоматов для  $L$ и $M$.

== Построение произведения автоматов $L$ и $M$

Вернёмся к проблеме разрешимости. Есть регулярные языки $L$ и $M$. Нужно выяснить, один и тот же ли это язык (эквивалентны ли они)? Это значит, что, если мы выберем в качестве языка конечный детерменированный автомат, оба автомата должны перевести слова в одни и те же конечные состояния. Но это хорошо, если нам известен язык. Если мы его не знаем, то мы можем построить специальный автомат, моделирующий работу этих двух автоматов --- это и есть автомат *произведения*. Как мы его определяем?


- Пусть КДА  $L$ и $M$ имеют множества состояний $Q$ и $R$ соответственно // TODO: да ебаный рот
// TODO: пункт
- Как мы определяем автомат произведения? Его состояния --- это множество состояний $Q times R$
 - т. е. пары $[q, r]$, где $q in Q, r in R$
// TODO: ещё пара пунктов



== Произведение автомато --- прод

- *Переходы* $delta ([q, r], a) = [delta_L (q, a), delta_M (r, a)]$
	- $delta_L$ $delta_M$ функции переходов для КДА $L$ и $M$
  - То есть, мы моделируем исходные конечные детерменированные автоматы в компонентах двух состояний автомата-произведения.
- Определим, заключительные состояния автомата --- произведения тех состояний $[q, r]$, в которых точно одно из $q$ и $r$ есть финальное состояние соответствующего автомата

== Пример: Произведение автоматов

#image("imgs/025.png")




== Алгоритм установления эквивалентности
- Заключительные состояния автомата-произведения --- те состояний $[q, r]$ в которых точно одно из $q$ и $r$ есть финальное состояние соотетствующего автомата.
- Т.о., автомат-произведение принимает $w$ $<=>$ $w$ в точности принадлежит языку для одного из $L$ или $M$
- $L = M <=>$ язык для автомата произведения пуст

=== Пример: Эквивалентность

#image("imgs/026.png")
// TODO: это пиздец даже начинать смысла нет, там мего д
// BUG: ЕГОР, ТЫ МЕНЯ ВИДИШЬ?
// А Я ТЕБЯ НЕТ

== Проблема вложения языков
- По данным регулярным языкам $L$ и $M$ определить, $L subset.eq M$?
- Алгоритм также использует конструкцию произведения автоматов.
- Как нужно определить финальное состоние $[q, r]$ автомата-произведения, чтобы я=его язык был пуст т. и. т. т., когда $L subset.eq M$?
*Ответ*: $q$ --- финальное, $r$ -- нет
- То есть $L$ не содержится в $M$ т. и. т. т., когда существует некоторая строка $w$такая, что $w in L$, но $w in.not M$. Такая строка могла бы перевести КДА для $L$в финальное состояние, но не смогла бы перевести КДА для $M$ в финальное состояние.
- Так что вопрос вложения -- это тот же самый вопрос о существовании строки, переводящей автомат-произведение в состояние $[q, r]$, где $q$ --- заключительное, $r$ --- нет
// TODO: у темы есть

=== Пример: вложения языков
// TODO: Тема сфоткал
#image("imgs/026.png")
// TODO: я уже это рисовал

Замечание: только одно финальное состояние недотижимо, язык для автомата произведения пуст, т. о. вложение выполняется


== Минимальный КДА для регулярных языков

- В принципе, так как м можем протестировать КДА на эквивалентность, то мы можем по данному КДА А найти КДА с наименьшим числом состояний, принимающий $L(A)$. Можно проверить все КДА (с числом состояний меньше, чем у А) на эквивалентность с А
// TDOO:

#image("imgs/027.png")

== Доопределение КДА до полного

#image("imgs/001.jpg")
#image("imgs/002.jpg")
#image("imgs/003.jpg")

Можно пойти от обратного.

== Эффективная минимизация числа состояний
- Построим таблицу со всеми парами состояний
- Если мы найдём строку (слово), которая *различает* два состояния (прееводдит точно одно состоняние из двух в заключительное), то пометим эту пару.
- В противном случае остояния в паре будут *неразличимыми*, и они могут быть объединены в одно состояние
- Алгоритм является рекурсивным по длине кратчайших различающихся строк.

- *Базис:* пометим пары с точно одним финальным состоянием
- *Индукция*: пометим $[q, r]$, если для некоторого входного символа $a, [delta (q, a), delta(r, a)]$ является помеченной
- После того, как больше нельзя ппометить ни одно состояние, непомеченные пары состояний объявляем эквивалентными и объединяем в одно состояние.
- $q -> s -> dots "nonfinal"$,
- $r -> t -> dots "final"$

== Транзитивность неразличимости

// TODO:

== Построение минимального КДА

- Предположим, что $q_1, dots, q_k$ --- неразличимые состояния.
- Заменим их одним *представляющим* состоянием $q$
- Тогда $delta(q_1, a), dots, delta(q_k, a)$ есть все неразличимые состояния
 - *NB!*: в противном случае, нам следвоало бы пометить по крайней мере на одну пару состояний больше
- Пусть $delta(q,a) =$ состояние - представитель для этой группы

== Пример: минимизация числа состояний

#table(columns:3, 
	table.header([**], [**], [**]),
	[$->$ *A*], [B], [C],
	[*B*], [D], [E],
	[*C*], [D], [F],
	[*D*], [D], [G],
	[*E*], [D], [G],
	[\* *F*], [D], [C],
	[\* *G*], [D], [G],
)


#image("imgs/004.jpg")
#image("imgs/005.jpg")
#image("imgs/006.jpg")
#image("imgs/007.jpg")
#image("imgs/008.jpg")
#image("imgs/009.jpg")

== Удаление недостижимых состояний

- К сожалению, комбинирование неразличимых состояний может оставить нас с недостижимыми состояниями в минимальном КДА.
- Таким образом, до или после, нужно удалить состояния, которые недостижимы из начального состояния.

== Ключевой момент

- Пусть мы скомбинировали (отождествили) все возможные состояния данного КДА, получили новый эквивалентный автомат с меньшим числом состояний.
- Может ли существовать другой эквивалентный КДА с меньшим числом состояний?
- Нет. Доказательство включает в себя минимизацию КДА, который мы получили, с гипотетически лучшим КДА.

/ Теорема о минимальном автомате: ДЛя любого КДА автомата $M = (Q, Sigma, delta, q_0, F)$ $exists$ эквивалентный КДА $A=(Q', Sigma, delta', q_0, F')$ без неразличимых состояний, допускающих тот же язык. Причём, если $M$ --- автомат без недостижиых состояний, то не существуетт КДА, допускающего $L(M)$ и имеющего состояний меньше, чем у автомата $A$.

*Доказательство*: нет другого меньшего автомата

- Пусть $A$ --- наш минимизированный КДА; пусть $B$ -- его меньший эквивалент.
- Предположим, что $A$ эквивалентен $B$.
- Рассмотрим объединённый комбинированный авотмат с состояниями из $A$ и $B$ (неважно, какое состояние начальное, но заключительные состояния --- это те, что были в $A$ и $B$).
- Используем различимость в её контрапозитивной форме:
 - То есть, если $w$ различает $delta(a, a)$ от $delta(p,a)$, то, конечно, $a w$ различает $q$ от $p$.
 - Следовательно, если состояния $q$ и $p$ неразличимы, то их последователи по некоторому $a$: $delta(q, a)$ и $delta(p, a)$ --- также неразличимы.

#image("imgs/010.jpg")

== Индуктивная гипотеза

Каждое состояние $q$ автомата $A$ неразличимо с некоторым состоянием ав....

Индукция проводится по длине кратчайшей строки, переводящей начальное состояние...

/ Доказаельство: Начальное состояния $A$ и $B$ неразличимы, так как $L(A) = L(B)$...

*Базис:* Начальные состояния $A$ и $B$ неразличимы, так как $L(A) = L(B)$

*IH:* Пусть строка длины $n < |w|$ переводит $A$ в некоторое состояние $r$, которое неразличимо с некоторым состоянием $p$ автомата $B$.

*Индукция*: Предположим, что $w = x a $ --- это кратчайшая строка, переводящая автомат $A$ в состояние $q$.

Согласно IH, строка $x$ переводит А в некотрое состояние, которое неразличимо с некоторым состоянием р автомата В.

Тогда $delta_A (r, a) = q$ неразличимо с $delta_B (p, a)$

#image("imgs/012.jpg")



== Разрешимые свойства для регулярных языков --- итоги

- *Следующие проблемы разрешимы для регулярных языков*:
- Проблема принадлежности языку $w in L$?
- Проблема пустоты $L=emptyset$?
- Проблема эквивалентности $L subset.eq M$?
- Проблема бесконечности языка: $|L| = infinity$?

== Свойства замыкания для регулярных языков:

*объединение, пересечение, разность, конкатенация, замыкание Клини, гомоморфизм, инверсный гомоморфизм*










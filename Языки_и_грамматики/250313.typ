= Лекция 5
== Детерминрованный конечный автомат

Формализм для определения языков, остоящий из:
- Входного алфавита ($Sigma$, обычно)
- Функция переходов ($delta$)
- Начальное состояние ($q_0$ в $Q$)
- Финальное состояние ($F subset.eq Q$)

Финальный и принимающий является синонимами

$ A = (Q, Sigma, delta, q_0, F) $
еще одна важная формула // TODO:

== Альтернативное представление: таблица переходов

Два вида 2 детерминированнных автоматов:
- Мура --- безвыходный
- Мили --- с выходами

== Недетерминированный конечный автомат
_Недетермининизм. Конструкция подмножеств. $epsilon$-переходы_

== Недетерминизм

*Недетерминированный конечный* автомат может находиться в несккольких состояниях // TODO: дописать

// TODO: == #text(fill: rgb("#"))

== Пример: Шахматная доска

#image("imgs/017.png")

#table(
  columns: 3,
  stroke: none,
  inset: 10pt,
  align: horizon,
  table.hline(),
  table.header(
    [], [r], [b]
  ),
  table.hline(),
  table.vline(x: 0),
  table.vline(x: 1),
  table.vline(x: 2),
  table.vline(x: 3),
  [1], [2, 4], [5],
  [2], [4, 6], [1, 3, 5],
  [3], [2, 6], [5],
  [4], [2, 8], [1, 5, 7],
  [5], [2, 4, 6, 8], [1, 3, 7, 9],
  [6], [2, 8], [3, 5, 9],
  [7], [4, 8], [5],
  [8], [4, 6], [5, 7, 9],
  [9], [6, 8], [5],
  table.hline(),
)


== Формальное определение НКА
- Конечное множество состояний, обычно $Q$
- Входной алфавтит, обычно $Sigma$
- Функция переходов 
// TODO:

== Функция переходов НКА
- $delta(q, a)$ есть множество состояний

- Расширим функцию на строки следующим образом:
- Базис: $delta (q, epsilon) = {q}$
- Индукция: $delta(q, w a /* g n e r g r o u p */) = limits(union.big)_(p #[ --- состояние p \ в delta(q, w)]) delta(p,a) $

$ P -> delta(p, a) -> delta(q', w) \
#h(5pt) dots -> delta(q'', w) \
#h(5pt) -> delta(p', a) -> delta(q''', w) $

#box(stroke: rgb(blue))[
	$ delta(q, w a) = union_(p in delta(q, W) delta(p, a)) $
]

== Язык НКА
- Строка $w$ принимается НКА если $delta(q_0, w)$ содержит по крайней мере хотя бы одно финальное состояние // TODO:
-
== Пример: Язык НКА
#image(imgs/017.png)

- Для нашей доскки и НКА мы видели, что строка $'r b b'$ принимается.
- Если вод состоит только из $b$, множество принимаемых состояний изменяется между ${5}$ и ${1,3,7,9}$, так что только строи чётной длины из $b$ принимаются
- Что относительно строк по крайней мере с одним $r$?

== Эквивалентность КДА и НКА
- КДА может быть преобразован в НКА, который принимает тот же язык.
- Если $delta_D (q, a) = p$, то пусть НКА имеет $delta_N (q, a) = {p}$.
- Тогда НКА всегда находится в множестве, состоящем точно из одного состояния --- состояния КДА, в котором он находится после чтения того же входа.

== Эквивалентность (2)

- Удивительно, но дя любого НКА существует КДА, принмающий тот же язык
- Доказательство базируется на #text(fill: rgb("#ff33ee"))[*конструкции подмножеств*] /* самый гламурный конспект */
- Число состтояний КДА может быть экспоненциальным по отношению к числу состояний НКА.
- Т.о., НКА принимают точно те же регулярные языки
#image("imgs/019.png")

// ахаххаххахах
== Конструкция подмножеств
- По данному НКА с состояниями $Q$, входами $Sigma$, функцией переходов $delta_N$, начальным состоянием $q_0$, и финальными состояними $F$ построим эквивалентный КДА у которого:
	- Состояния $2^Q$ (подмножества множества $Q$)
	- Входы $Sigma$
	- Начальное состояние $q_0$
	- /* предположительно конечное состояние */

=== Замечание 
- Состояния КДА *имена*, которые обозначают множества состнояний НКА
- Но как говорит определение КДА, выражение подобное ${p, q}$ // ПАПШЕВ БЛЯТЬ ШЛЮХА
-
== Конструкция подмножеств --- (2)

- Функция переходов $delta_D$ определяется так
$ delta_D ({q_1, dots, q_k})$ dots

$ q_D (({q_1, dots, q_k}, a) = limits(union)_(i = 1)^k delta_N (q_i, a)) $

- Мы построим КДА, эквивалентный клеточному

#table(
  columns: 3,
  stroke: none,
  inset: 10pt,
  align: horizon,
  table.hline(),
  table.header(
    [], [r], [b]
  ),
  table.hline(),
  table.vline(x: 0),
  table.vline(x: 1),
  table.vline(x: 2),
  table.vline(x: 3),
  [1], [2, 4], [5],
  [2], [4, 6], [1, 3, 5],
  [3], [2, 6], [5],
  [4], [2, 8], [1, 5, 7],
  [5], [2, 4, 6, 8], [1, 3, 7, 9],
  [6], [2, 8], [3, 5, 9],
  [7], [4, 8], [5],
  [8], [4, 6], [5, 7, 9],
  [9], [6, 8], [5],
  table.hline(),
)

#table(
  columns: 3,
  stroke: none,
  inset: 10pt,
  align: horizon,
  table.hline(),
  table.header(
    [], [r], [b]
  ),
  table.hline(),
  table.vline(x: 0),
  table.vline(x: 1),
  table.vline(x: 2),
  table.vline(x: 3),
	[$-> {1}$], [{2, 4}], [{5}],
	[{2, 4}], [{2, 4, 6, 8}], [{1,3,5,7}],
	[{5}], [{2, 4, 6, 8}], [{1,3,5,7}],
	[{2,4,6,8}], [{2,4,6,8}], [{1,3,5,7,9}],
	[{1,3,5,7}], [{2,4,6,8}], [{1,3,5,7,9}],
	[\*{1,3,7,9}], [{2,4,6,8}], [{5}],
	[\*{1,3,5,7,9}], [{2,4,6,8}], [{1,3,5,7,9}]
)

Мы продолжаем гулять по автомату, пока в таблице не закончат появляться новые пререхоы

== Доказательство эквивалентности: конструкция подмножеств
- Доказательство:
- Покажем индукцией по $|w|$ (длине слова, как всё обычно и доказывается в мире языков), что
$ delta_N (q_0, w) = delta_D ({q_0}, w) $
- Базис: $ w = epsilon : delta_N (q_0, epsilon) = delta_D ({q_0}, epsilon) = {q_0} $
// это не in, а epsilon

== Индукция
Индуктивна гипотеза, что автоматы будут обрабатывать строки короче $w$.
- Пусть $I H$ выполняется для строк короче, чем для $w$
- Пусть $ w = x a$; IH выполняется для $x$
- Пусть $T = limits(union.big)_(p in S) delta_N (p, a)$, где $p$ --- состояние
- Тогда $delta_N (q_0, w) = delta_D ({q_0}, w) = T $.

Итак, мы сформулировали гипотезу. Теперь давайте посмотрим наши переходы по множеству $S$, какие есть в нашем недетерменированном автомате.

По построению нашего автомата мы смотрели все наши множества из $S$, проходили по ним и все их получили. Значит, индуктивный переход тоже обоснован $=>$ (КДА $<=>$ НКА #text(fill: rgb("#aaa"))[$<-> epsilon "НКА"$]))

== НКА с $epsilon$-переходами
- Мы можем допустить переходы между состояниями по входу $epsilon$.
- Эти переходы  происходят спонтанно, без оглядки на входную строку.
- Иногда это удобно, но принимаются те же реггулярные языки, что принимаются КДА и НКА
// HACK:
// Егор, а вим может работать в режиме HEX редактора?
// Не пон
// Редактировать не текст, а байты
// Загугли HxD
// Есть)

== Пример: $epsilon$-НКА

#image("imgs/020.png")


$ A = (Q, Sigma, delta_E, q_0, F) $
$ delta_E : Q times (Sigma union {epsilon}) -> 2^Q $


// Мне пиздец ща раздуплюсь

== Замыкание состояний

#image("imgs/021.png")

- $C L(q) =$ множество состояний, которые мы можем достичь из состояния $q$ следуя по дугам, помеченным $epsilon$
- Пример: $C L (A) = {A};$ $ C L (E) = {B, C, D, E} $
- Замыкание множества состояний = объединение множеств замыканий по каждому из состояний множества

$C L({B, C, D, E}) = C L(B, D) union C L(c) union C L(D) union C L (E) = d union emptyset union emptyset union {B,C,D,E} = {B,C,D,E} $

== Расширенная дельта
#text(fill: rgb("#ff4400"))[Интуитивно]: $ delta (q, w)$ --- множество состояний, которые можно достичь из $q$ слдуя по пути, помеченным $w$. $[N B !: delta(q, epsilon) eq.not delta(q, epsilon)]$
е
- #text(fill: blue)[Базис]: $delta(q, epsilon) = C L (q)$
- #text(fill: blue)[Индукция]: $delta(q, x a)$ вычисляется так: \
Начать с $delta(q, x) = S$ \
Возьмём $limits(union.big)_(p in S) C L (delta(p, a))$
// Ненавижу блять физру на локомотиве, у меня опять началась эта хуйня с первого сема
// F
== Пример: Расширение дельты

#image("imgs/021.png")

- $delta^\^ (A, epsilon) = C L (A) = {A}$
- $delta^\^ (A, 0) = C L ({E}) = {B, C, D, E} $
- $delta^\^ (A, 01) = C L ({C, D}) = {C, D}$ // HACK: ^\^ выглядит как uwu какое-то нахуй
- Языком $epsilon$-НКА является мнжоество строк $w$ такое, что $delta^\^ (q_0, w)$ содержит финальное состояние
- $A = (Q, Sigma, delta_E, q_0, F), space delta_e: Q times (Sigma union {epsilon}) -> 2^Q$
- $L(A) = {w: delta^\^ (q_o, w) inter F != emptyset}$

В чём заключается идея? Допустим, у нас есть строка $0 epsilon 1 epsilon$, которая суть то же, что и $ 0 1 $. 

Суть дельты с крышкой заключается в том, что дельта с крышкой прыгает и по эпсилонам тоже, что отличает её от обычной дельты.

Но есть интересный кейс: $epsilon #box(stroke: black, $0 epsilon$) #box(stroke: black, $1 epsilon$)$. Что делать с первым $epsilon$?

// HACK: 
// Еврейской бабушке Саре очень понравился скайп.
// — Нет, вы таки посмотрите, какая вещь! И вроде бы у нас гости, а кормить не надо.
// - АХАХАХААХАХАХАХАХХАХАХХАХАХАХХА

Глядя на наш граф:

$ delta^\^ ({A,B,C}, 0) = C L ({D, C, A}) = {A, B, C, D} $

// HACK:
// Я с физры до конца этого месяца выподаю, ибо ну нахуй, я ебал еще раз в больницу ложиться из-за этой хуйни

== Эквивалентность НКА, $epsilon$-НКА
- Каждый НКА является $epsilon$-НКА.
	- Он только не имеет $epsilon$-переходов.
- Доказательство обратного требует от нас взять $epsilon$-НКА и построить НКА, который принимает тот же язык.
- Мы сделаем это путём комбинирования $epsilon$-переходов следующим переходом по реальному входу.

/* HACK:
   Однажды Мюллер придумал замечательный способ узнать, какой же всё—таки Штирлиц национальности.
   Он решил пригласить его в гости и понаблюдать, как тот уйдёт:
   Если не попрощавшись, значит, англичанин.
   Если выпив всё спиртное, перебив посуду и совратив хозяйку — русский.
   Если найдя и съев всё сало — украинец.
   Но когда Штирлиц вообще не ушёл, а стал жить у Мюллера, постепенно перетаскав к нему свои вещи, группенфюрер наконец догадался, что Штирлиц — еврей.
	- АХАХАХХАХАХААХАХА
*/

== Иллюстрация удаления $epsilon$-переходов
Поскольку мы не выполняем замыкания состяний после перехода по $a$. Мы должны сделать дополнительные конечные состояния --- те, из которых можно достичь конченого состояния только по $epsilon$

#image("imgs/021.png")

== Эквивалентность --- (2)
- Возьмем $epsilon$-НКА с состояниями $Q$, входами $Sigma$, начальным состоянием $q_0$, финальными состояниями $F$, и функцией переходов $delta_E$.
- Постром "обычный" НКА с состояниями $Q$ входами $Sigma$, начальным состоянием  $q_0$, финальными состояниями $F'$, и функцией переходов $delta_N$.

#image("imgs/022.png")
== Эквивалентность ---(3)
#image("imgs/023.png")
- Будем вычислять $delta_N (q, a)$ следующим образом: // TODO:
// HACK:
// Я ебал, это пиздец, хуй успеешь заним иногда
== Пример: от $epsilon$- НКА к НКА

#image("imgs/024.png") // TODO: ВСТАВИТЬ СКРИН ИЗ ПРЕЗЫ, СПИЗДИВ ЕГО ПРЕДВАРИТЕЛЬНО У СОЛОВЬЁВА МЛАДШЕГО








// BACK POINT






























































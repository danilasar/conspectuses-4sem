= Лекция ... 3 апреля 2025
== Свойства регулярных языков

- Класс языков --- это множество языков
	- Пример: регулярные языки
- Классы языков имеют два вида важных свойств 
	1.
	2.



=== Разрешимые сввойства для регулярных языков --- итоги

Следующие проблемы разрешимы для регулярных языков:

- Проблема принадлежности языку $w in L$?
- Проблема пустоты $L = emptyset$?
- Проблема эквивалентности $L = M$?
- Проблема вложения языков $L subset.eq M$?
- Проблема бесконечности языка $|L| = infinity$?

=== Свойства замыкания для регулярных языков

Объединение, Пересечение, Разность, Конкатенация, Замыкание Клини, Гомоморфизм, Инверсный гомоморфизм

=== Замкнутость класса регулярных языков относительно регулярных операций

=== Замыкание по конкатенации и операции Клини

Та же идея:
- $R S - P B$ языком для которого является язык $L M$

== Замыкание по пересечению

*Теорема*. Если L и M – регулярные языки, то таковым
будет язык $L inter M$.

*Доказательство*:

Пусть $A$ и $B$ – КДА, определяющие языки
$L$ и $M$, соотвественно.

Построим автомат $C$ – произведение автоматов A и B.

Сделаем финальными состояниями C пары, состоящие из
финальных состояний $A$ и $B$.

Очевидно, что данный автомат будет принимать только те слова, которые принадлежат $L$ и $M$, т. е. $L inter M$.

_Почему Сергей Владимирович называет эти языки округлыми? Взглянём на рисунок:_
#image("imgs/028.png")

== Пример: КДА-произведение для пересечения

#image("imgs/029.png")


== Пример: Использование свойства замыкания пересечения

- Мы доказали с использованием леммы о накачке, что
    - $L_1 = {0^n 1^n | n > 0}$ - не регулярный язык.
    - $L_2$ = множество строк с равным числом $0$ и $1$ тоже не РЯ, но этот факт трудно доказать напрямую.
    - Предположим, что $L_2$ – регулярный язык.
- Регулярные языки замкнуты относительно $inter$.
- Если L2 регулярный, то $L_2 inter L(0*1*) = L_1$ тоже должен бы быть регулярным, но мы уже установили, что это не так.

// Фиксим форматирваниеи и формулы

Оказывается, что всё это имеет весьма практическое примение. Для доказательства нерегулярности языка $L_1$ мы использовали теорему о накачке. При накачке у нас раздуваются нули и их становится больше единиц, чего быть не может $=>$ язык нерегулярный.

К языку $L_2$ применить лемму о накачке уже затруднительно. Будем доказывать от противного.

=== Замыкание по вычитанию

*Теорема*. Если $L$ и $M$ – регулярные языки, то таким является язык $L$ – $M$ (строки из $L$, но не из $M$).

*Доказательство*: Пусть $A$ и $B$ --- КДА, языками которых
являются $L$ и $M$ соотвественно.
- Построим автомат $C$ – произведение автоматов $A$ и $B$.
- Сделаем финальными состояниями автомата $C$ пары, которые состоят из финальных состояний $A$ и нефинальных $B$.
- Автомат С допускает точно строки из L – M.
- Следовательно, L – M – регулярный язык.

_Докажем это, опираясь на представление языка в качестве конечного детерменированного автомата. Строим произведение языков --- автомат $C$. Финальными у него сделаем финалы $A$, которые не являются финалами $B$._

_Автомат точно пропускает строки из $L - M$, именно поэтому мы так выбрали наши финальные состояния._

_Раз мы построили автомат для этого языка, значит, он регулярный_

#image("imgs/031.png")


=== Пример: КДА --- произведение для разности языков

#image("imgs/030.png")

Финальное состояние $[B,D]$ недостижимо из начального состояния, так что данная версия автомата-произведения принимает пустой язык. Это должно быть так, потому что первый автомат принимает подмножество того, что принимает второй. То есть, первый автомат принимает все строки, заканчивающиеся нечетным числом $1$, а второй $278$ принимает все строки, заканчивающиеся по крайней мере одной $1$, плюс пустая строка.

== Замыкание по дополнению

- Дополнением языка $L$ (по отношению алфавита $Sigma$, так что $Sigma\*$ содержит $L$) является язык $Sigma\* --- L$.

- Так как $Sigma\*$ очевидно регулярный и регулярные языки замкнуты по операции вычитания, дополнение регулярного языка всегда будет регулярным языком.

_Когда мы говори о дополнении, мы должны оговаривать, до чего мы дополняем. В качестве универсального языка мы используем множество всех слов в афлавите $Sigma$. Это регулярный язык. Если $L$ --- тоже регулярный язык, то дополнение --- это $Sigma^* - L$._

_Мы только что выяснили, что операция вычитания регулярного языка из регулярного языка даёт нам регулярный язык._

== Замыкание по обращению

Пусть дан язык $L$, и $L^R$ - есть множество строк, обращение
которых есть в $L$.

Пример: $L = {0, 01, 100}$;
- $L^R = {0, 10, 001}$.
- Если $L$ – регулярный язык, то $L^R$ – тоже регулярный язык.

*Доказательство:*

Пусть $E$ есть регулярное выражение для L. Мы покажем как обратить $E$, чтобы произвести регулярное выражение $E^R$ для $L^R$.


== Обращение регулярного выражения

Базис: Если $E$ символ $a$, $epsilon$, или $emptyset$, то $E^R$ = $E$.

Индукция: если $E$ есть
- $F+G$, то $E^R$ = FR + GR.
- $F G$, то $E^R$ = $G^R F^R$
- $F\*$, то $E^R$ = $(F^R)\*$.

#image("imgs/032.png")

== Пример: Обращение РВ
Пусть $E = 01\* + 10\*$.
$
E^R = (01\* + 10\*)R = (01\*)R + (10\*)R =\
= (1\*)^R 0^R + (0\*)^R 1^R =\
= (1R)\*0 + (0R)\*1 =\
= 1\*0 + 0\*1.
$

_Мы берём сумму регулярных выражений. Замыкание --- самая сильная операция, поэтому выполняем её прежде других операций._

== Гомоморфизмы
/ Гомоморфизмом: на алфавите является функция, которая каждый символ этого алфавита заменяет некоторой
строкой.

*Пример*: $h(0) = a b$; $h(1) = epsilon$.

Расширим функцию на строки $h(a_1 dots a_n) = h(a_1) dots h(a_n)$.

Пример: $h(01010) = a b a b a b$.

#image("imgs/033.png")

== Замыкание по гомоморфизму
Если $L$ --- регулярный язык, и $h$ есть гомоморфизм на его алфавите, то $h(L) = {h(w) | w in L}$ также является регулярным языком.

*Доказательство:* Пусть $E$ --- РВ для $L$.

Применим $h$ к каждому символу в $E$.

Язык для результирующего РВ есть $h(L)$.


// РВ --- это регулярные выражения, не формула

== Пример: Замыкание по гомоморфизму
Пусть $h(0) = a b$; $h(1) = epsilon$.

Пусть $L$ --- язык для регулярного выражения $01\* + 10\*$.

Тогда $h(L)$ будет регулярным языком для РВ 

$ a b epsilon* + epsilon(a b)*. $

*Замечание*:

используем скобки, чтобы сделать правильное группирование

== Пример --- продолжение
- $a b epsilon\* + epsilon(a b)\*$ можно упростить.
- $epsilon* = epsilon,$ так что $a b epsilon\* = a b epsilon$.
- $epsilon$ - есть единица по конкатенации.

То есть, $epsilon E = E epsilon = E$ для любого РВ $E$.

То есть, $a b epsilon + epsilon(a b)\* = a b + (a b)\*.$

Наконец, $L(a b)$ содержится в $L((a b)*)$, так что RE для $h(L)$ есть $(a b)\*$.


== Обратный гомоморфизм
Пусть $h$ — гомоморфизм и $L$ есть язык, алфавитом которого является результирующий язык функции $h$.

Определим:

$h^(-1) (L) = { w | h(w) in L}$.

== Пример: обратный гомоморфизм
Пусть $h(0) = a b$; $h(1) = epsilon$.

Пусть $L = {a b a b, b a b a}$.

$h^(-1) (L) = $ язык из 0 и любого числа 1 $= L(1*01*01*)$.

_Теперь немножко посложнее, поэтому здесь потребуется напряжение мысли. Как работает инверсный (обратный) гомоморфизм? В его результате получается новый язык, где строки одного алфавита заменяются строками другого алфавита_

_Пусть  на выходе гомоморфизма $h(limits(dots)_arrow.t) = L$_

_Вот чтобы найти язык $dots$ (обозначим его за $M$) и существует обратный гомоморфизм: $h^(-1) (L) = M$_

_По строке $a b a b$ мы в целом смогли восстановить исходный язык. А вот попытка восстановить $b a b a$ не увенчается успехом, поэтому мы просто игнорируем её: на нет и суда нет._

== Доказательство замыкания по обратному гомоморфизму

Начнём с КДА $A$ для $L$.

Построим КДА $B$ для $h^(-1) (L)$ с:

- Тем же самым множеством состояний, что и у $А$,

- Тем же начальным состоянием,

- Теми же финальными состояниями.

- Входной алфавит = символы, к которым применяется гомоморфизм $h$.

Переходы для $B$ вычисляются путём применения $h$ к входному символу $a$ и просмотра того, куда $A$ мог бы пройти по последовательности символов $h(a)$.

Формально, $delta_B (q, a) = delta_A (q, h(a))$.

// степени расставил

#image("imgs/035.png")
// ебать стабильность
// а в виме щас рестартили бы всё
// к сожалению
// один хуй пока пишем раздельно, но совокупляем в одном, это не самый удобный вариант
// да стабильный, но не торт
== Пример: построение обратного гомоморфизма

#image("imgs/034.png")

== Доказательство --- обратный гомоморфизм

Индукция по $|w|$ показывает, что
$ delta_B(q_0, w) = delta_A (q_0, h(w)). $

Основа доказательства: $w$ переводит автомат $B$ из начального состояния в состояние $p$ тогда и только тогда, когда $h(w)$ переводит автомат $A$ из начального в то же стстояние $p$.

Таким образом, $B$ принимает $w space <=> space A$ принимает $h(w)$.

== Свойства замкнутости для регулярных языков
- Замкнутость класса регулярных языков относительно регулярных
операций
- Замкнутость по дополнению
- Замкнутость по пересечению
- Замкнутость по вычитанию
- Замкнутость по обращению (слов)
- Замкнутость по гомоморфизму
- Замкнутость по обратному гомоморфизму

// HACK: a b \* входит, значит можно попустить)))))

// ебать стабильность
// а в виме щас рестартили бы всё
// к сожалению
// один хуй пока пишем раздельно, но совокупляем в одном, это не самый удобный вариант
// да стабильный, но не торт
// надо фиксить вим
// ну бля, я тоже в виме хочу писать
// будет время --- пофиксим
_Вот теперь мы знаем все свойства замыканий, выполняемые для регулярных языков. Это, что называется, хорошие языки, ведь для них почти всегда всё да_

=== Разрешимые сввойства для регулярных языков --- итоги

Вспомним разрешимые разрешимы для регулярных языков:

- Проблема принадлежности языку $w in L$?
- Проблема пустоты $L = emptyset$?
- Проблема эквивалентности $L = M$?
- Проблема вложения языков $L subset.eq M$?
- Проблема бесконечности языка $|L| = infinity$?


#quote(block: true, attribution: [Папшев Сергей Владимирович], [Мы эти языки крутим как хотим])

#image("imgs/036.png")

Вот мы и закончили изучать регулярные языки. Если у нас язык задаётся автоматом, то мы его в этом случае можем назвать автоматным языком. Те же самые языки можно задавать праволинейными или леволинейнымии грамматиками, хотя мы предпочитаем использовать именно праволинейную. Почему? Потому что в её случае строка всегда растёт вправо, это естественный для человека способ построения строки. И мы знаем, что праволинейные грамматики и конечные автоматы могут быть получены друг из друга, это две равноправные формы построения грамматики.

Наконец, мы знаем, что языки --- это суть регулярные множества, мы можем построить их с помощью объединения, конкатенации и итерации, записывая всё это в форме регулярных выражений.

Когда мы не хотим конкретизировать способ задания языка, мы называем его просто --- регулярным языком.

Все преобразования мы на практике выполняли. Один и тот же регулярный язык можно задать разными регулярными выражениями, разными праволинейными грамматиками и разными автоматами.

Что мы будем делать дальше?

#image("imgs/037.png")

Мы рассмотрели самый первый класс языков --- регулярный язык --- и установили, что распознающими для них являются конечные детерменированные автоматы.

Дальше мы будем изучать КС-языки, которые распознаются автоматом с магазинной памятью.

Линейно-ограниченные автоматы --- это модифицированная машина Тьюринга.

// HACK: 
// Армянин с гемороем играя в нарды
// бросил кубик
// У него выпало очко

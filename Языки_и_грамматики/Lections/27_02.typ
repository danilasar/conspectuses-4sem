= Лекция 3.

== Грамматикирамматики

Иерархия грамматик Хомскаого

/ Утверждение 5.: Справедливы следующие:

2. Любая неукорачивающая КС-грамматика блять

== Иерархия языков

// FIX: #image("imgs/001.png")

== Разбор цепочек

/ Цепочка: в алфавите $T$ принадлежит языку, порождаемому грамматикой $(T, N, P, S)$ только в том случае, если существует ее вывод из начального сивола $S$ этой грамматики.

/ Разбор: --- процесс построения такого вывода.

Построение вывода можно осуществить и в обратном порядке: в исхоной цепочке ищем вхождение в неё правой части некоторого правила и заменяем его на левую часть (делаем свёртку).

- В итоге исходная  цепочка "сворачивается" к некотрой сентенинциальной форме. Затем идет следующая свертка и т.д., пока не придем к $S$

/ Анализ: --- описанный выше процесс разбора снизу вверх.

=== Пример

$ G_"expr" = <{a, b, +}, {S, T}, {S -> T | T + S: T -> a | b}, S>$

Можно построить разные выводы для цепочки $a + b + a$:
+ $S -> T + S -> T + T + S -> T + T + T -> a + T + T -> a + b + T -> a + b + a$
+ $S -> T + S -> a + S -> a + T + S -> a + b + S -> a + b + T -> a + b + a$
+ $S -> T + S -> T + T + S -> T + T + T -> T + T + a -> T + b + a -> a + b + a$

Дерево разбора выглядит так:

// FIX: #image("imgs/002.png")

Когда мы займёмся КС-грамматиками, мы много будем говорить о деревьях. На вышенарисованном листья --- символы выведенной цепочки, а промежуточные узлы --- это нетерминальные символы.

Пошагово дерево можно отобразить так:

// FIX: #image("imgs/003.png")

== Регулярные множества, их распознавание и порождение

Введение в грамматики закончилось, мы начинаем изучать классы языков и грамматик по отдельности. Начнём с самого простого класса языков --- языков типа 3, также называемых регулярными. Почему они так называются? Сейчас узнаем.


/ Опр.: Пусть $Sigma$ --- конечный алфавит. Регулярное множество в алфавите $Sigma$  оперделяется следующим образом:

+ $emptyset$ --- регулярное множество в алфавите $Sigma$
+ ${epsilon}$ --- регулярное множество в алфавите $Sigma$
+ ${a}$ --- регулярное множество в алфавите $Sigma$ $space forall a in Sigma$
+ Если  $Q$ и $R$ --- регулярные множества в алфавите $Sigma$, то множества $Q union P$, $Q P$ и $P\*$ регулярные.
+ Ничто другое не является регулярным множеством в алфавите $Sigma$

Попробуем посмотреть на пример.

Пусть задан алфавит \
$Sigma = {a, b}$ \
и язык \
$ L  = { (a b)^n : n gt.eq 1 } $

Как нам определить, является ли множество строк $a b, a b  a b, dots$ частью языка? Для этого нам надо показать, что по заданным правилам мы можем построить это множество.

Из алфавита $Sigma$ мы можем построить два множества \
${a}, {b}$, \
а затем сделать их конкатенцию: \
$ { a }, { b } => { a b } $

Возьмём итерацию ${ a b }^*$ и получим загаданное множество.

Но дело в том, что описание, аналогичное $L$, не всегда возможно для регулярных множеств. Тогда как нам просто и компактно описать это бесконечное множество? Для этого существуют *регулярные выражения*.


Perl-синтаксис регулярных выражений не полностью соответствует тому, который мы будем разбирать сейчас, потому что там он является расширенным и имеет дополнительные синтаксические конструкции, строящиеся на основе уже разбираемого нами синтаксиса.


== Регулярные выражения

/ Опр.: Пусть $Sigma$ --- конечный алфавит. Определим рекурсивно _регулярное выражение в алфавте_ $Sigma$ и регулярные множества, которые они обозначают.

Базис индукции:
+ $emptyset$ --- регулярное выражение, обозначающее регулярное множество $emptyset$
+ $epsilon$ --- регулярное выражение, обозначающее регулярное множество ${epsilon}$
+ $a in Sigma$ --- регулярное выражение, обозначающее регулярное множество ${a}$

Индукция:

Если $alpha$ и $beta$ --- регулярные выражения, обозначающие регулярные множества $Q$ и $P$ соответственно, то:
+ $(alpha + beta)$ --- регулярное выражение, обозначающее $Q union P$
+ $(alpha beta)$ --- регулярное выражение, обозначающее $Q P$
+ $(beta)^\*$ --- регулярное выражение, обозначающее $P^\*$

Никаких других регулярных выражений, кроме тех, что построены в соответствии с описанным определением, нет.

_Скобки в приведённых примерах являются элементами определения регулярного выражения. Они могут опускаться подобно тому, как они опускаются в арифметике. Так, если операция итерации применяется к единственному символу $beta$, скобки можно опустить._

$ (a b)^\+ $

/ Лемма1: Если в $alpha, beta, gamma$ --- регулярные выражения, то справедливы следующие соотношения:

1. $alpha + beta = beta + alpha$
2. $alpha + (beta + gamma) = (alpha + beta) + gamma$
3. $alpha(beta + gamma)$ = $alpha beta + alpha gamma$
4. $alpha epsilon = epsilon alpha = alpha$
5. $alpha\* = alpha + alpha\*$
6. $alpha + alpha = alpha$
7. $emptyset^\* = epsilon$
8. $alpha (beta gamma) = (alpha beta) gamma$
8. $alpha(beta gamma) = (alpha beta gamma)$
9. $(alpha + beta)gamma = alpha gamma + beta gamma$
10. $emptyset alpha = alpha emptyset = emptyset$
11. $(alpha^\*)^\* = alpha^\*$
12. $alpha + emptyset = alpha$

/ Доказательство: Пусть $alpha, beta$ обозначают множества $Q$ и $P$ соответственно. Тогда $alpha + beta$ обозначают $Q union P$, а $beta + alpha$ --- $P union Q$

Но $ Q union P = P union Q$.  Следовательно, $alpha + beta = beta + alpha$.

Эти тождества помогают при построении регулярных выражений: мы абстрагируемся от множеств и правил их преобразования, пользуясь уже доказанными тождествами. Поэтому превая задача, которая для нас присутствует, --- это упрощение регулярного выражения.

=== Пример преоразования RE
 
Пусть язык задан регулярным выражением:
$L = (0\* + epsilon)\*(1+1^+)$

Имеем:

1. $0^\* = 0^+ + epsilon => L = (((0^+ + epsilon) + epsilon)^\*(1 + 1^+))$
2. $L = (0^\+  epsilon + epsilon)^\* (1 + 1^\+)$ (опустили скобки)
3. $L = (0^\+ + epsilon)^\* (1 + 1^\+)$
4. $L = (0^\*)^\*(1 + 1^+)$
5. $(0^*)^* = 0^* => L = 0^\* (1 + 1^*)$
6. $1 dot 1^\* = 1^+ => L = 0^\* 1(epsilon + 1^\*)$ (т. к. $1 ( limits(union.big)_(i = 0)^infinity 1^i)$)
7. $L = 0^\* 1 1^\*$
8. $1 dot 1&\* = 1^+ => L = 0^\* 1^\+$

$ L = { 0^n 1^m | n gt.eq 0, m gt.eq 1 } $

*Такая задача будет в кр*

*Контрольная работа будет через неделю после того как завершим тему "Регулярные выражения"*

=== Примеры регулярных выражений

$Epsilon = {0, 1}$
- $L(01) = {01}$
- $L(01 + 0) = {01, 0}$
- $L(0(1+0)) = {01, 00}$
- $L(0^\*) = {epsilon, 0, 00, 000, dots}$
- $L((0+10)^\*(epsilon+1)) =$ все строки из 0 1 и без двух последовательных 1

Фактически регулярные выражения задают шаблоны строк. В языках программирования такая технология широко используется.

*Примеры* регулярных выражений над алфавитом ${a, b}$:

$ a + b, (a + b)^\*,  (a a, (a b)^&\* b b)^\*$

Соответствующие языки:
- $L(a + b) = {a} union {b} = {a, b}$
- $L((a+ +  bb)^\*) = {a, b}^\*$
- $L((a a (a  b)^\* b b)^\*)  = { a a a b b b, dots }$
// гг 3 пункту
// живём живём

== Уравнения с регулярными коэффициентами

Есть три способа задания языков:
+ Регулярные выражения
+ Прямолинейные грамматики
+ Конечные автоматы

// FIX: #image("imgs/004.png")

_Доказательство выводимости регулярного выражения из конечного автомата существует, но оно настолько неприятно, что им пользуются только постоянные клиенты психоневрологического диспансера и изолятора_

Рассмотрим уравнение $X = a X - b$? где $a$ и $b$ --- $P B$

$ X = a^\* b "- решение уравнения:" $
$ a^\* b = a a^\* b + b $
$ a^\* b = (a a^\* + epsilon) b $
$ a^\* b = a\^* b $

Если множество, определяемое рег. выражением $a$, содержит $epsilon$, то уравнение имеет бесконечно много решений $X = a^\* (b + c)$ для любого $P B$ с.

В этом случае берут _"наименьшее решение"_ --- *наименьшую неподвижную точку*

== Система уравнений с регулярными коэффициентами


/ Опр.:  Система уравнений с рег. коэффициентами называется *стандартной системой* с множеством неизвестных $Delta = {X_1, X_2, ..., X_n}$, если она имеет вид:

$
	x_1 = a_(10) X_1 + a_(12) X_2 + dots + a_(1 n) X_n \
	dots dots dots dots dots dots dots dots dots dots dots dots dots dots dots \
	x_n = a_(n 0) X_1 + a_(n 2) X_2 + dots + a_(n n) X_n,
$
где все $a_(i j)$ --- регулярные выражения в алфавите, не пересекающимся с $Delta$.

Если $a_(i j) = emptyset$? то соответствующее слагаемое соответствует. \
Если $a_(i j) = epsilon$, то слагаемое равно $X_j$.





































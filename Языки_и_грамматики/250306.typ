= Лекция 4. 06 Марта 2025


Способы задания языков:
- Описательный. К сожалению не для всех типов грамматик его можно осуществить. Но для грамматик типа 3 есть способ описания в виде регулярных выражений. Он основан на определении праволинейного языка.

$P M <-> P B$
Если $G$ --- праволинейная грамматика, то $L(G)$ ---  ... // TODO: праволинейный язык или что?пра

/* я подсосался
меня видно? */
// да, видно


== Регулярные множества и праволинейныйе грамматики

Язык определяется праволинейнй грамматикой т.и.т.т., когда он является регулярным множеством.
- Лемма 3. Множества $emptyset, {epsilon}, и a$ для всех $a underline(in) Sigma$ являтся праволинейными языками. 

- Док-во:
1. $G=(({S}), Sigma, P, S)$ --- праволинейная грамматика, для которой $L(G)=$ // господа с первой парты, чему равно L(G)?
2. $G({S}, Sigma, {S -> epsilon}, S)$ --- праволинейная грамматика для ...
3. $G_"п" = ({S}. Sigma, {s->a}, S})$ --- праволинейная грамматика, для которой $L(G) = {a}$

- Лемма 4. Если $P и Q$ --- праволинейные языки, то языки

+ $P union Q$,
+ $P Q$,
+ $P^\*$

тоже праволинейные.

- Док-во конструктивное --- мы строим эти грамматики:

Так как $P$ и $Q$ --- праволинейные, то $exists$ праволинейные грамматики
$ G_P = (N_1, Sigma, P_1, S_1)$ и $G_Q = (N_2, Sigma, P_2, S_2)$,  для которых $L(G_P) = P$ и $L(G_Q) = Q$ Считаем что $N_1 sect N_2 = emptyset$.

1. $G_3 = (N_1 union N_2, Sigma, P_1 union P_2 union {S_3 -> S_1 | S_2}, S_3)$ --- праволинейная $L(G_3) = L(G_P) union L(G_Q)$, так как для каждого вывода $S_3 => /* TODO: ??? */ w$ 

т.к. для каждого вывода $S_3 limits(=>)^+_(G_3) w$ и обратно.


Так как $G_3$ --- праволинейная грамматка, то $L(G_3)$ --- праволинейный язык

2. $G_4 = (N_1 union N_2, Sigma, P_4, S_1)$ --- праволинейная.

  $P_4$:
  1. Если $A -> x B$ есть в $P_1$, то $A -> x B$ принадлежит $P_4$.
  2. Если $A -> x$ есть в $P_1$, то $A -> x S_2$ принадлежит $P_4$.
  3. Все правила из $P_2$ принадлежит $P_4$.



Отметим, что если $S_1 limits(=>)^+_(G_P) w$, то $S_1 limits(=>)^+_(G_4) w S_w$, а если $S_2 limits(=>)^+_(G_Q) x$, то $S_2 limits(=>)^+_(G_4) x$.

Таким образом $L_(G_P) L_(G_Q) subset.eq L(G_4)$.



#image("imgs/007.png")

#image("imgs/008.png")


Пусть $S_1 =>^+_(G_4) w $. Т.к. в $G_4$ нет правил $A -> x$, попавших из $P_1$, то этот вывод можно сделать так: $S_1 limits(=>)^+_(G_4)$ $x S_2 limits(=>)^+_(G_4)$, где $w = x y$ и все правила в выводе $S limits(=>)^+_(G_4) w S_2$ попали в $P_4$ по (1) и (2).

Следовательно, должны быть выводы $(S_1 => limits(G_P)^+)$ и $S_2 => limits(G_Q)^+ y$.

Отсюда $L(G_4) subset.eq L_(G_P) L(G_Q)$

3. Пусть $G_5 = (N_1 union {S_5}, Sigma, P_5,S_5)$ такая, что $S_5 in N_1$ и $P_5$:
 1. $A -> x B$ есть в $P_1$ $=>$ $(A -> x B) in P_5$
 2. $(A -> x) in P_1 => (A -> x S_5), (A -> x) in P_5 $
 3. $(S_5 -> S_1 | epsilon) in P_5$

Очевидно, что
$ S_5 =>^+_(G_5) x_1 S_5 =>^+_(G_5) x_1 x_2 S_5 =>^+_(G_5) dots =>^+_(G_5) x_1 x_2 dots x_(n - 1) x_n $


$<=>$, когда $S_1 =>^+_(G_P) x_1, S_1 =>^+_(G_P) x_2, dots, S_1 =>^+_(G_P) x_n$

Отсюда следует, что $L(G_4) = (L(G_P))*$


== Теорема.
Язык является регулярным множеством $<=>$ он праволинейный.

- Док-во:

*Необходимость*:

Следует из лемм 3 и 4, индукцией по числу шагов построерния регулярного нмножества, гед одни шаг --- это применение одного из правил, определяющих регулярные множества.


*Достаточность*:

Пусть $G = (N, Sigma, P, S)$ --- праволинейная грамматика и $N = {A_1, A_2, dots, A_n}$.

Можно построить старндартную систему уравнений с регулярными коффициентами, неизвестными которой являются нетерминалы из $N$.

Уравнение для $A_i$ будет иметь вид: $A_i = a_(i 0) + a_(i 1) A_1 + dots a_(i n)$, где

1. $a_(i 0) = w_1 + dots + w_k $, если $A_I -> w_1 | dots | w_k$ --- все правила с левой частью $A_i$ и правой частью, состоящей только из терминалов ($k = 0 => a_(i 0) = 0$)

2. Для $ j gt 0 a_(i j) = x_1 + dots + x_m$, если $A_i arrow.r x_1 A_j | dots | x_m A_j$ --- все правила с левой частью $A_i$ и правой частью, оканчивающуюся на $A_j$ (если $m = 0$, то $a_(i j) = 0$)/


Решая эту систему уравнений получаем решенеие $f$ для $N = { A_1, A_2, dots, A_n }$

Для $S$ получаем $P B space f(S)$, которое определяет язык $L(G)$.

Но алгоритм строит $f(S)$ как язык, обозначаемый некоторым $P B$.

Таким образом, $L(G)$ --- регулярное множество.

*Пример на доске*:

#image("imgs/009.png")


=== Пример построения грамматики по $P B$

Рассмотрим регулярное выражение $(0 + 1) * 2$. Построим праволинейную грамматику, определяющую тот же язык:

- Для языков ${0}, {1}, {2}$ определим грамматики (согласно леммам):
$ G_0 = ({S_i}, {0, 1, 2}, {S_i} -> 0}, S_i) $
$ G_1 = ({S_i}, {0, 1, 2}, {S_i} -> 1}, S_i) $
$ G_2 = ({S_i}, {0, 1, 2}, {S_i} -> 2}, S_i) $
// TODO: превые парты, убедитесь, что я всё правильно увидел

// РВ -- это скращение от регулярных выражений, не формула
- Для РВ $0 + 1$ по грамматикам $G_0$ и $G_1$ строим грамматику

$
P_3 = { S_3 - S_0, \
  S_3 - S_1, \
  S_0 - 0, \
  S_1 - 1, }
$


- Для $P B space (0 + 1)\*$ по грамматике $G_3$ строим грамматику $G_4 = ({ S_4, S_3, S_0, S_1 }, {0, 1, 2}, P_4, S_4) $, где $P_4$
- $
    S_4 -> S_3 | epsilon\
    S_3 -> S_0 | S_1\
    S_0 -> 0 S_4| 0\ 
	  S_1 -> 1 S_4 | 1
  $
- Для $P B (0 + 1)\* 2$. Построим праволинейную грамматику

$G_5 = {{S_4, S_3, S_0, S_1, S_2}, {0, 1, 2}, P_5, "что-то"} $ // TODO: дописать

где $P_5$:


// БЛЯЯЯЯЯ КУДА ВСЁ ИСЧЕЗЛО
// СУКАААА
// пизздеееееец
// здесь был даня нахуй
// u не работает?

определяющую тот же язык.

- Пусть дана грамматика, определяемая правилами:

$
  S arrow.r 0 A | 1 B | epsilon
  A arrow.r 0 A | 1 B | 2
  B arrow.r 0 B | 1 A
$


- рассмотрим систему уравнений: 
  $ 
    S = 0 A + 1 B - epsilon\
    A = 0 A + 1 B - 2\
    B = 0 B - 1 A
  $

- Выразим $B = 0* 1 A$ и подставим его значение в 1-е и 2-е уравнения:
  $
    S = 0 A + 10\* 1 A - epsilon\
    A = 0 A + 10\*  1 A - 2\
    B = 0\* 1 A
  $

- Выразим $A = {0 + 10 * 1}*2$ и подставим его в первое уравнение:
  $
    S = 0(0 + 10\*1)\*2 + 10\*1(0 + 10\*1)\*2 + epsilon\
    A = (0 - 10\* 1)\* 2\
    B = 0\* 1 A
  $

Выражение ля $S$ можно преобразовать к виду $S = (0 - 10 * 1) + 2 + epsilon$

Это РВ будет определять то же регулярное множество (регулярный язык), что и данная праволинейная грамматика.

== Конечные автоматы и регулярные множества.

Наибольшую популярность получили именно конечные автоматы, потому что они служат не только для описания регулярных языков, но и для описания модели алгоритма, работающего в режиме дискретных шагов, --- именно так работают почти все алгоритмы, ведь это заложено в определении.

/ Конечный автомат --- это\::
- Формальная система
- Помнит только конечное количество информации
- Информация представляется его *состояниями*
- Состояние изменяется под воздействием *входов*
- Правила, которые говорят, как изменять состояние под воздействием входов, называются переходами

Что является ключевой особенностью? Объект, названный нами автоматом, короче давайте рисовать.

Этот автомат умеет работать с некоторыми символами, поступающими на вход.

$ underbracket(a(t) -->, #[вход]) limits(square)_(S(t)) $

// FIX : #image("imgs/010.png")
// FIX : #image("imgs/011.png")

$a_i in Sigma, s(t + 1) = delta(s(t), a(t))$ --- функция перехода


=== Допустимые входы

- Дана последовательность входов (входная строка).
- Начать в начальном состоянии и следовать по переходу по каждому очередному символу входной строки.
- Вход принимается, если вы перенеслись в финальное (принимающее) состояние после чтения всех входных символов.

=== Язык автомата

- Множество строк, принимаемых автоматом $A$, являются _языком_ автомата $A$.
- Обзонгачается $L(A)$
- Различные множества финальных состояний $->$ Разные языки.

=== Детерминированный конечный автомат

- Формализм для определения языков, состоящих из:
  - Конечного множества состояний (Обозначается обычно $Q$)
  - Входной алфавит ($Sigma$, обычно)
  - Функция переходов ($delta$, обычно)
  - Начальное состояние ($q_0$ в $Q$, обычно)
  - Финальные состояния ($F subset.eq Q$, обычно)

_Примечание: на зачёте, отвечая на вопрос про детерминированный конечный автомат, нужно не только перечислить эти компоненты, но и дать определение функции переходов, иначе ответ будет неполный_


$ 
  A = (Q, Sigma, delta, q_0, F)\
  delta: Q times Sigma -> Q
$ // TODO: чекнуть мб не прав в "-> Q"

== Функция переходов

- Имеет два аргумента: состояние и входной символ.

- $delta(q, a) = $ состояние, в которое КДА переходит, если он в состоянии $q$ получает на вход символ $a$.

- #text(fill: rgb("#eeee00"))[Замечание:] всегда есть следующее состояние --- добавим #text(style:"italic", fill: rgb("#ff00ee"), "Мёртвое состояние") если нет переходов (Пример далее) // TODO: фиксануть градиент
// курсивный текст можно определять _подчёркиваниями_ по обе стороны (на будущее)

- Форма задания: таблица переходов, граф.
- Функцию пееходов можно доопределить для слов:
$
  delta^star (q, a) = delta (q, a) "если" |a| = 1\
  delta^star (q, a w) = delta(delta^star (q, w), a)
$

Начальное состояние указывается стрелочкой $->$, а конечное (заключительное) --- звёздочкой $star$

#text(fill: rgb("#00ee00"), "Пример:")
#image("imgs/012.png")
#image("imgs/013.png")

// HACK:
// если чел сидит афк на строке, ничего страшного не происходит
// главное не писать одновременно, а то расухярит
// Этот плагин учит не перебивать людей))))




=== Расширенная дельта 
- Мы не будем различать обозначения $delta$ и $delta^star$

- Причина: $delta^star (q, a) = delta(delta^star (q, in.small), a) = delta(q, a)$ --- Расширенная дельта --- $delta^star$
// HACK:
// ИДИТЕ НАХУЙ
// Я ЭТО НЕ НАРИСУЮ
// НАШЛИ БЛЯТЬ ЛЕОНАРДО ДАЙ ВИНЧИКА
// Даня опухнет от этих примеров)))))

// HACK:
// грустная история про то, как упал сервер
// Сервер который просто хотел жить


// TODO: Поменять цвета на более подходящие (везде)
#text(fill: rgb("#00ee00"), "Пример:") Распозначание строк, оканчивающихся на "ing"

#image("imgs/014.png")

#text(fill: rgb("#00ee00"), "Пример:") Протокол для пересылки данных

#image("imgs/015.png")
#image("imgs/016.png")


#text(fill: rgb("#00ee00"), "Пример:") Строки без 11

- Строка еще не иммет $11$. Не оканчивается 1.
- Строка еще не имеет $11$. Но оканчивается на 1.
- Найдены две 1 идущие подряд

// я не успел нарисовать


#text(fill: rgb("#eeee00"), "соглашение:") Строки и символы.

- $dots w, x, y, z$ --- строки
- $a, b, c, dots$ ---- одиночные входные символы

== Язык К/*У*/ДА /*нахуй*/

- Автоматы всех видов определяют языки.
- Если $A$ --- автомат, $L(A)$ --- его язык.
- Для К/*У*/ДА /*НАХУЙ*/ $A$, $L(A)$ есть множество строк, помечающих пути из начального состояния в финальное
- #text(fill: rgb("#eeee00"), "Формально:") $L(A)$ // TODO: дописать


=== Доказательство равенства множеств

Часто нам нужно доказать, что два описания множеств определят фактически одно и то же множество.

В нашем случае одно множество "КДА" // TODO: дописать

// HACK: БЛЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯ

*Док-во*

- В общем, чтобы доказать $S = T$, нам нужно доказать две части: $S subset.eq T and T subset.eq S$. То есть

- Если $w$ есть в $S$, то $w in T$
- $w in T => w in S$

- В нашем случае:
$S = L(A)$, т.е., quote.angle.l.double S --- есть язык нашего автомата А quote.angle.r.double

$T = #[в словах языка нет двух последовательных единиц]$

== #text(fill: rgb("#1109BB"))[Часть 1]: $S subset.eq T$
- 
- Доказатьельство  индукцией по..

// HACK: БЛЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯ че за спидран ебаный
== Индуктивная гипотеза

$
	delta(A, w) = A => "последовательные" 1 in.not w and w " не заканчивается на " 1 \
	delta(A, w) = B => /* TODO: бляяяя */
$

- Базис: $|w| = 0$; т.е. $w = epsilon$ 
  - (1) выполняется, т.к. $in.small$ не имеет 1 совсем
- (2) выполняется т.к. $delta(a, b)$ не является $B$

=== Индуктивный шаг
- Пусть (1) и (2) выполняются для строк короче чем $w$ ....
- По предположению ... // TODO: дописать...
- Так как $w$ не пуста, можно записать $w = x a /*xaxaxaxaxa*/$ // вот тебе и хаха наху
// HACK:
// СУКААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА
// что происходит
// я уже не ориентируюсь

=== Индуктивный шаг --- 2
- Нужно доказать (1)
// HACK: ебать его в жопу с такой с коростью ебаный рот
=== Индуктивный шаг --- 3
- Так как $delta(A, w) =$ // HACK: ДА ТЫ ЗАЕБАЛ БЛЯТЬ МОЛНИЯ МАКВИН СУКА


== #text(fill: rgb("#1109BB"))[Часть 2]: $T subset.eq S$

- Теперь мы должны доказать: если $w$ не имеет 11, то принимается

- От противного: если 
// сука это закончится сегодня или нет
// через одну минуту
// пошли покажем конспект
// исходник именно
// я ни при чём XD



// HACK:
// Cumнец


































= Лекция ... 28 апреля 2025

== Векторное и растровое изображение

Есть Кривые Безье, которыми можно задать прямую, через три точки

// FIX: #image("imgs/195.png")

// sdkljfalkjf
// я в темп засунул потом перенесу


// СВО НАХУЙ
короче пишем раздельно и вставляем

// Кривые Без Е
// Ааххахаааххаха

// assasini atsasini

Сейчас рассмотрим алгоритм построения отрезка когда у нас задана пара точек, а мы хотим заполнить пиксели на экране таким образом, чтобы то, что мы видим на экране, было похоже на отрезок.


ок все норм

== Алгоритм Растеризации отрезка
Задача алгоритма: выбрать такие точки, чтобы они были ближайшие к отрезку

До растеризации и после растеризации:
// FIX: #grid(columns:2, image("imgs/196.png"),
// FIX: #image("imgs/197.png"))





== Алгоритм Брезенхема


// Ебанные рассинхрон

Переходя от пикселя к пикселю

мы наш отрезок будем отрисовывать по шагам


От начального пикселя по $x$ до

// вставляй сюда

Для каждой колонки растра мы поставим одну точку. Мы в каждой колонке растра выбираем пиксель который зажгем. 

Если посмотреть в какой точке пересекает /// СУКА Я НЕ УСПЕВАЮ БЛЭТ


$epsilon$ --- расстоние ... 


*Надо растеризацию отрезка у Ани спросить*

== Первый вещественно значный алгоритм с углом от $0$ до $45^o$

// в пизду формулы, надо скринить, я не успеваю
// 22 слайд:
#grid(columns:2,
grid(columns:2,
$ sigma_0 = x_2 - x_1 $, $sigma_0 > 0$,
..{
	for i in range(1,4) {
		let j = i - 1
		($sigma_#i = sigma_#j - 2 (y_2 - y_1)$, if i == 3 { $sigma_3 <= 0$} else {$delta_#i > 0$})
	}
	}
),

grid(columns:2,
$ epsilon_0 = 1/2 $, $ epsilon_0 gt 0$,
..{
	for i in range(1,4) {
		let j = i - 1
		($epsilon_#i = epsilon_#j - (y_2 - y_1)/(x_2 - x_1)$, if i == 3 { $epsilon_3 <= 0$} else {$epsilon_#i > 0$})
	}
	},
	$ times 2 (x_2 - x_1) \ 2(x_2 - x_1) epsilon = sigma$
)
)

// слайд 23
$
delta x = x_2 - x_1\
delta y = y_2 - y_1\

Delta y = (delta y)/(delta x)\
epsilon = 0.5\

x = x_1\
y = y_1
$

```
какой-то псевда код
```

// 24 слайд:
$
delta x = x_2 - x_1\
delta y = y_2 - y_1\

sigma = delta x\

x = x_1\
y = y_1
$
```
Точка (x, y)
Пока x != x_2 {
  x = x + 1
  sigma = sigma - 2 delta y
  если sigma <= 0 {
    y = y + 1
    sigma = sigma + 2 delta x
  }
    точка (x, y)
}
```
$
delta x = |x_2 - x_1|\
delta y = |y_2 - y_1|\

s x = #[sign] (x_2 - x_1)\
s y = #[sign] (y_2 - y_1)\

sigma = delta x\

x = x_1\
y = y_1
$

```
точка (x, y)
Пока x != x_2 {
  x = x + sx
  sigma = sigma - 2 delta y
  если sigma <= 0 {
    y = y + sy
    sigma = sigma + 2 delta x
  }
  точка (x, y)
}
```


// 25 слайД:
// NOTE: формула и псевокод — копипаста предыдущего
#grid(columns: 2,
grid.cell(colspan:2, 
$
delta x = |x_2 - x_1|\
delta y = |y_2 - y_1|\

s x = #[sign] (x_2 - x_1)\
s y = #[sign] (y_2 - y_1)\

sigma = delta x\

x = x_1\
y = y_1
$
),
image("imgs/199.png"),
```
точка (x, y)
Пока x != x_2 {
  x = x + sx
  sigma = sigma - 2 delta y
  если sigma <= 0 {
    y = y + sy
    sigma = sigma + 2 delta x
  }
  точка (x, y)
}
```
)

Мы получили универсальный целоисленный алгоритм Брезенхема.

// 26,27,28 слайд:
#image("imgs/200.png")
#image("imgs/201.png")
#image("imgs/202.png")

// 29 слайд:
#grid(columns: 2,
grid.cell(colspan:2, 
$
delta x = |x_2 - x_1|\
delta y = |y_2 - y_1|\

"along" Y = delta y > delta x \
"если" "along" Y { "swap"(delta x, delta y) } \

s x = #[sign] (x_2 - x_1)\
s y = #[sign] (y_2 - y_1)\

sigma = delta x\

x = x_1\
y = y_1
$
),
image("imgs/199.png"),
```
точка (x, y)
Пока x != x_2 или y != y_2 {
  если alongY { y = y + sy }
  иначе {x = x + sx}
  sigma = sigma - 2 delta y
  если sigma <= 0 {
    если alongY { y = y + sy }
    иначе {x = x + sx}
    sigma = sigma + 2 delta x
  }
  точка (x, y)
}
```
)

// бывает)
// блять помогите как это записывать, мб, НАХУЙ, просто скрины?

// слайд 33:
#grid(columns: 2,
grid.cell(rowspan:2,
image("imgs/204.png")),
image("imgs/203.png"),
$
	Delta z = (z_2 - z_1)/(delta x) \
	Delta r = (r_2 - r_1)/(delta x) \
	Delta g = (g_2 - g_1)/(delta x) \
	Delta b = (b_2 - b_1)/(delta x)
$
)

// слайд 34:
== Растеризация многоугольника
#image("imgs/205.png")
На каждом шаге перед отрисовкой точки. мы добавляем $Delta$ к (r, g, b).


Мы предполагаем, что у нас многоугольник без пересечений

Это важный алгоритм на нем базируется алгоритм отсечение в трехмерном ...

Мы должны закрасить писксели таким образом, чтобы в конце концов получилась фигура, которая

Многоугольник можно представить как набор ребер, но это не хорошо, так как задавая ребро мы храним точку два раза. Но пока мы так будем делать

// слайд 35:
#image("imgs/206.png")

// слайд 36:
$ A B -> y_1 <= y_2 $

Можно задать набором точек:

A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q

Предположим, что у нас правая система координат

У нас есть вершины прямоугольника, заданы целочисленными значениями (вещественные в любом случае приведутся к целочисленным)

Упорядочим концы так, чтобы // TODO:


Мы будем закрашивать снизу вверх, построчно, тк многоугольник, есть многоугольник

/ Когерентность строк растра:

// слайд 37, 38: 
$
"Active  Edge List (AEL)" \
Delta x = (x_2 - x_1) / (y_2 - y_1) \
(x, Delta x, y_2) \
y_2 != y_1 \
y_2 != y_1
$
Будем использовать список отрезков, который будем называть список активных ребер --- AEL --- Acrive Edge List

Каждый отрезок, который входит в список активных ребер ...

Для каждого растра свой AEL

// слайд 39:
- $y_"min"$
- $y_"max"$
- $"AEL"$ --- список активных рёбер. Это список рёбер, которые пересекает текущая строка растра. Каждое входящее в него ребро будет представлен тройкой значений.
- $y_"cr"$ --- $y$ критическое --- момент, в который надо будет пересмотреть все точки --- это или что-то, или минимальное значение координат начальной точки тех рёбер, которые ещё не рассматривали // TODO:
- $y_"cur"$ --- базовое ззначение, которое обозначает, какую строку мы рассматриваем в базовый момент.

Заносить горизонтальные ребра рисуем сразу не занося в //

Есть список ребер и список активных ребер.

В начальный момент мы должны найти y_min и y_max в списке ребер. Чтобы понять где начать и где закончить


// слайд 40 с псевдокодом:
#image("imgs/207.png")

// слайд 40:

На стартовой обстановке критическое и текущее $y$ одинаковы и равны единице, а AEL --- пустое множество:
$y_"cur" = y_"cr" = 1 \
"AEL" = {} $
$"AEL" = { Q A, P O, N O, N M, L M, L K} = {(5, -1, 5), (7, 1, 3), (12, - 3/2, 3), (12, 1, 3), dots}$

Горизонтальные отрезки в AEL не попадают, мы их отрисовываем тут же.

/ Парный отрезок: --- когда из конца одного выходит начало другого
/ Непарный отрезок: --- когда из конца одного не выходит начало другого

// НА ЭТОМ ПАРА ЗАКОНЧИЛАСЬ, СОБАКУ ЗАРЫЛИ ЁПТЕЛЬ МОПСЕЛЬ*к

// слайд 41:
#image("imgs/208.png")

// слайд 42:
#image("imgs/209.png")

// слайд 43:
$y_"cr" = 3$

// слайд 44:
$y_"cur" = 1 \
"AEL" = {(4, -1, 5), (8, 1, 3), (21/2, -3/2, 3), (13, 1, 3), dots}$

// слайд 45:
$y_"cur" = 2$

#image("imgs/210.png")

// слайд 46:
$"AEL" = {(4, -1, 5), (8, 1, 3), (21/2, -3/2, 3), (13, 1, 3), dots} = {(3, -1, 5), (9, 1, 3), (9, - 3/2, 3), (14, 1, 3), dots}$
// Ебать вовремя у меня уши разложило)))

// слайд 47:
$y_"cur" = 3$

#image("imgs/211.png")

$"AEL" = { Q A, P O, N O, N M, L M, L K} = {(3, -1, 5), (9, 1, 3), (9, - 3/2, 3), (14, 1, 3), dots}$

$"AEL" = { Q A, L K } = {(3, -1, 5), (172/10,1/10,11)}$

$y_"cr" = 4$

// слайд 48:

$y_"cur" = 4$

$"AEL" = { Q A, E D, E F, L K } = {(2, -1, 5), (7, 0, 8), (7, 2, 5), (173/10, 1/10, 11)}$

// слайд 49:
#image("imgs/212.png")

// я хз куда это


= 17 февраля 2025. Лекция 2.

При использовании ноутбуков для ведения конспектов обязательно сидеть на первых партах. Звуки на устройствах должны быть выключены, смартфоны и всё остальное запрещено.

Мы рассматриваем самые основы компьютерной графики и не охватываем всю эту область. Для компьютерной графики существует множество устройств вывода. Мы рассматриваем немного вывода, математические основы и немного алгоритмов.

#image("imgs/test.png")

Рассмоатриваем только элементы интерактивной компьютерной графики


/ Интерактивная графика: --- это вопрос написания графических приложений, требующих обратную связь с пользователем. Элементы графического изображения зависят от действий пользователя. (покадрово просчитывается)

/ Интерактивный: --- взаимодействие внутри приложения

/ Не интерактивное приложение: --- анимации, отрисовка одного кадра

Создание аницации с помощью средств математики.

Неинтерактивная графика имеет посредственное отношение к компьютерной графики, особенно если не применяются математические или алгоритмические способы генерации изображения в реальном времени.

// писать нспект с этой штукой --- это как сидеть и нихуя не делать, пока товарищ батрачит
// он перестаёт успевать и ты бежишь на помощь

// ага

Любая наша лабораторная работа определяется при том, что мы работаем в рамках концепции событийно-ориентированного программирования.

/ Событийно ориентированное программирование: --- пардигма програмирования, когда предполагается что есть временная линия и в ней возникают определенные события. (Paint, Load, Resize, Key down)


// оставляй пустую строку за собой чтобы я тебя не сбивал

Событийно-ориентированная программа не описывается простой последовательностью действий и ни в коем случае нелинейна, она состоит из множества обработчиков событий. Много разонвидностей событий --- много обработчиков. В винформах у нас оконное приложение уже по умолчанию достаточно сложная система, имеющая множество видов событий и их обработчиков. В 7-8 лабораторной работах обработка событий будет выглядеть немного иначе.
// понял

/ Обработчики событий: --- выполняются, когда события происхрдят. Они могут происходить без нашего требования или с нашей подачи, но в любом случае перехватываются обработчиком, который выполнит определённые действия. 

/ Paint: --- событие винформ (в Qt PaintEvent), которое происходит при каждом обновлении изображения на экране. Собственно, она и отвечает за рендеринг окна. Подраазумевает, что в обработчике событий и происходит вся отрисовка.

У нас нет большого числа способов взаимодействия с приложением, в большинстве случаев это лишь клавиатура и мышь, что значительно упрощает нашу работу. 

Перейдём к ходу лабораторных работ. Во время их выполнения мы не будем заниматься чем-то большим, чем рисование отрезков.

Из отрезков составляем грани, фигуры и тп. С помощью алгоритмов рассматриваем, что мы можем с ними сделать.

/ Полигональная компьютерная графика: (полигональные модели компьютерной графики) --- то, на чём строится вся компьютерная графика. Есть, конечно, и исключения --- это бесспорно, поэтому полигональные модели не единственные, хотя являются абсолютно доминирующими.

Например, миры в играх строятся, в основном только, полигональными моделями.

/ Воксель: --- кубик. На основе кубиков стооится *воксельная графика*

Когда мы говорим об отрезках, базовая координата графики --- это координата точки. Когда мы говорим о графическом объекте, мы описыфваем его с помощью набора вершин и говорим, какие вершины соединяются отрезками. Вершины каким-то образом соединяются, этими соединениями можно строить закономерности и так далее. В случае многоугольников мы описываем, какие точки образуют многоугольник и в каком порядке их нужно соединять, чтобы построить контур многоугольника.

Чтобы нарисвоть отрезок нужно использовать команду вывода отрезка на экран (название команды (new line что ли))

В разном масштабе один и тот же набор точек будет выглядеть по-разному, поэтому нужно с какой-то детализацией найти набор точек и соединить их отрезками. Если точек слишком мало, фигура будет угловатой. Слишком большое количество точек теряет смысл и создаёт лишь лишнюю вычислительную нагрузку.

/ Любая кривая Безье: --- отрисовывается также пикселями

Кривую мы задаём тремя и более (!) точками. _Прим. от Дани: традиционно кривая Безье задаётся тремя точками, но существуют уравнения, позволяющие задавать более сложные кривые практически неограниченным набором точек_

Когда задаем окружность мы задаем точку и радиус.

3-4 лабы --- есть некоторое изображение. Эту модель мы будем использовать. Эту модель мы изображаем и задаем ее в некоторой декартовой системе координат. Строим как набор отрезков. Вычисляем точки в своей системе координат, где эта модель описана. Эту систему координат будем называть модельной (Объектной или система координат объектов или локальная система координат).

/ Модельная (объектная) система координат: (система координат объекта, локальная система координат) --- декартоаа система координат, в которой мы строим своё изобажение. По умолчанию в рамках лабораторных работ считается, что мы рисуем в правой системе координат.

Правость и левость систем координат определяется взаимным расположением x и y по окружности: если по часовой сначала y, потом x, то это правая система координат.

/ Система координат экрана: --- целевая система координат (в той части экрана, где надо вывести изображение).

По умолчанию в винформах  начало координат находится в левом верхнем углу и система координат направлена в лево: последовательность y, x идёт  против часовой. Она называется *системой координат экрана*

Экранная система координат (*НИКОГДА НЕ ПРОИЗНОСИМ ЭТО*) != Система координат экрана. Только система координат экрана валидна.

#image("imgs/001.png")

/ Мировая система координат: ---

Герой может быть описан по частям. (Например, голова отдельно). И потом можно его собрать (для движения частей модели)

// Все збс, но надо Шефа попросить удленитель таскать, ибо батарея разряжается пиздец

// ещё на вим его посадим, будем вместе конспектировать

// ага

Основная операция(Кадрирование):

Во всей этой картине основным преобразованием является *операция кадрирования*. Её смысл --- это совмещение одного кадра с другим --- преобразование кадра для совмещения с другим кадором.

/ Кадр: --- прямоугольник стороны, которого параллельны осям координат и у которого есть параметры. В качестве параметров будем брать $V_(c x), V_(c y)$ $V_x, V_y$

- $V_(c x)$, $V_(c y)$ --- координаты левого нижнего угла
- $V_x$ --- ширина
- $V_y$ --- высота
- $W_(c x)$ ---
- $W_(c y)$ ---
- $W_x$ --- ширина новой системы координат
- $W_y$ --- высота новой системы координат

#image("imgs/002.png")
#image("imgs/003.png")

Берем точку и должны найтив в кадре точку, где должны ее отобразить. Мы это достигаем за счёт  того, что размер изображения пропорционально изменяется. 

#image("imgs/004.png")
От каждого:

Вычислим положение рисунка в промежуточной системе координат:
$
	x_1 = x - V_"cx" \
	y_1 == y - V_"cy"
$

Сделаем эти координаты безразмерными.

$
	forall p = (V_x, V_y) in P, " где " P " - рисунок": \
	cases(
		x_2 = frac(x - V_(c x), V_x),
		y_2 = frac(y - V_(c y), V_y)
	) \
	(x_2, y_2) " - безразмерные координаты"
$

Умножим безразмерные координаты наа размер новой области:

$
	cases(
		x_3 = frac(x - V_(c x), V_x) W_x,
		y_3 = frac(y - V_(c y), V_y) W_y
	) \
$


$
	cases(
		x'_3 = frac(x - V_(c x), V_x) W_x + W_(c x),
		y'_3 = frac(y - V_(c y), V_y) W_y + W_(c y)
	) \
$

Мы выводили уравнения для перевода из правой системы координат в правую, для двух левых вычисления и их результаты будут теми же самыми. Иначе выйдет, если мы захотим из правой истемы координат кадрировать в левую. То есть мы хотим сделать так:

#image("imgs/005.png")

Выполняя приведённые выше вычисления, мы получим не совсем тот результаатаа:

#image("imgs/006.png")

Для решения проблемы неправильного поворота достаточно $y$ умножить на минус единицу:
$
	cases(
		x'_4 = frac(x - V_(c x), V_x) W_x + W_(c x),
		y'_4 = - frac(y - V_(c y), V_y) W_y - W_(c y)
	) \
$

После чего сдвинем получишееся изображение повыше --- туда, где мы и ожидали его увидеть изначально:
$
	cases(
		x'_5 = frac(x - V_(c x), V_x) W_x + W_(c x),
		y'_5 = - frac(y - V_(c y), V_y) W_y - W_(c y) + 2W_(c y)
	) \
$

Запишим итоговый результат так:
$
	cases(
		x' = frac(x - V_(c x), V_x) W_x + W_(c x),
		y' = W_(c y) - frac(y - V_(c y), V_y) W_y
	) \
$

Это преобразование делает сдвиг с неравномерным масштабированием. Мы сможем использовать получившееся уравнение для преобразования как из правой в левую, так и из левой в правую.

/ Сдвиг и масштабирование: --- это такое афинное преобразование, которое сохраняет прямые и отрезки, меняются только размеры и пропорции.

Применяем преобразование кадрирования ...

Есть и другая задача, которая, правда, сводится к операции кадрирования: мы хотим изображение не растянуть/сжать, а уместить в целевой кадр с *сохранением пропорций*. Масштабирование в таком случае равномерное, мы увеличиваем обе координаты в одно и то же количество раз.

$
cases(
    W_x/V_x,
    W_y/V_y
)
$

Чтобы такая операция работала, привязка к левому нижнему углу не обязательна. А обязательно равенство коэффициентов, для достижения чего мы возьмём минимальный из них. Минимальность гарантирует невылезание за рамки кадра, а равенство гарантирует пропорциональность --- задача решена.

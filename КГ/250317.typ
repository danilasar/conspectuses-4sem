Ранее обсуждалось, что прямая $l$ определяется однородными координатами прямой $(A, B, C)$: $A x + B y + C = 0$.

В случае точки однородные координаты таковы:

$ P ~ (chi, psi, alpha) = ( chi / alpha, gamma / alpha) $

$(2, 3, 0)$ --- однородные координаты бесконечно удалённой точки.

Рассмотрим точки $P_1 (chi_1, gamma_1, alpha_1)$ и$P_2 (chi_2, gamma_2, alpha_2)$
С помощью вектторного произведения $P_1 times P_2 = l$ (при условии $P_1 != P_2$) мы получили прямую. В случае равенства точек получится нулевой вектор.

Из принципа двойственности получается, что, если у нас есть $l_1 times l_2 = P $.

Отметим, что трёхмерные точки будут иметь четырёхмерные однородные координаты.

$A x + B y + C z + D = 0$ --- уравнение плоскости.

Плюкровы координаты прямой --- это представление прямой в виде матрицы 4x4, с ними столкнуться можно в рамках проективной геометрии.

$P = L beta$ --- однородные координаты плоскости $beta$, где $L$ --- однородные координаты прямой.

== Построение 2D-графика

График функции --- это нечто бесконечное в ширину и высоту и в детализацию.

График можно построить и более совершенными методами, но мы будем делать это в лоб операцией кадрирования.

#image("imgs/031.png")

Для этого мы выбираем некоторый шаг разбиения, для каждого $x_i = x_(i - 1) + Delta_x$ определяем $y_i$.

$
	x' = (x - V_(c x))/V_x W_x + W_(c x) \
	y' = W_(c y) - (y - V_(c y)) / V_y W_y
$

#image("imgs/032.png")

$
	x_0 = V_(c x) -> x'_0 = W_(c x) \
	y_0 = f(x_0) -> y'_0 \ \
	x_i = x_(i - 1) + Delta x -> x'_o \
	y_i = f(x_i) -> y'_i
$

Отрезок от $(x'_(i - 1), y'_(i - 1))$ до $(x'_i, y'_i)$.

```cpp
цикл (пока x_i < W_cx + W_x)
```

Как выбрать $Delta_x$, чтобы график был нормальным? При выборе значения мы будем отталкиваться от экрана, что позволит сделать график визуально гладким.

// HACK: ВСЕ ПИКСЕЛИ В КЛЕТКАХ, ГУЛАГ, ПОЛОВИНА СИДИТ, ПОЛОВИНА ОХРАНЯЕТ

/* HACK: 
 * Хохол идет по лесу, вдруг ему навстречу выскакивает здоровенный кабан. Оба застывают, остолбенев.
 * «Кабан!» – испуганно думает хохол.
 * «Хохол!» – испуганно думает кабан.
*/

Ну а теперь займёмся растровой графикой. 

// почему фото из презентации с жёлтым квадратом выглядит как скрин документалки с рен тв

/* HACK: 
 * Возвращается украинец из зоопарка, куда ходил смотреть на яка.
 * Кум его спрашивает:
 * – Як як?
 * – Ну як як? Як як як.
*/

// это мотивация первашам лекции редачить

$ x'_0 = W_(c x), x = V_x \ 
	y'_0 <- y_0 = f(x_0) \ \
	#[```cpp
		пока x'_i <= W_cx + W_x
	```] \
	x'_i = x'_(i - 1) + 1 -> x_i \ 
	y'_i <- y_i = f(x_i)
	"обрезок от " x'_(i - 1), y'_(i - 1) " до " (x'_i, y'_i) \ \

	x_i = x_i + #box(stroke: black, inset: 7pt)[$V_x/W_x$]
$

Стоит понимать, что существуют также точки разрыва функции (как в случае с гиперболой на $x = 0$)

#image("imgs/033.png")

Нынешний метод нарисует в этом месте лишний отрезок. Мы, конечно, можем /*быть долбоёбом и */хранить массив точек разрыва. Одна из проблем в том, что на разных дискретизациях точки могут немного различаться. Но и это фиксится: мы можем взять окрестность вокруг точки разрыва.

Но и здесь проблема: на большом масштабе эта окрестность будет невообразимо большой. Пофиксим это тем, что окрестность должна быть равна единичному шагу.

Как это будет в наших лабах? У нас будут две функции --- $f(x)$ и $"fexists"(x, delta)$. Последняя проверяет, попала ли точка $x$ в $delta$-окрестность одной из точек разрыва.

=== Масштабирование

Чтобы растянуь график относитлеьно центра кадра в $S_x, S_y$ раз по осятм $O_x, O_y$, нужно масштабировать окно относительно центра кадра, тю ею применить операции
- масштабирования точки $(V_(c x), V_(c y))$ относительно центра окна
- масштабирования величин $V_x, V_y$ (вектора $(V_x, V_y$) в $S_x, S_y$ соответственно

// TODO: матрица от Егора должна быть вставлена сюды

$
mat(delim: "[",
	V'_(c x);
	V'_(c y);
	1
) = mat(
	S\*_x, 0, T\*_x;
	0, S^\*_y, T^*_y;
	0, 0, 1
) mat(delim: "[",
	V_(c x), V_(c y), 1
)
$

$
mat(delim:"[", 
	V'_x;
	V'_y
) = mat(
	S\*_x, 0;
	0, S^\*_y
) mat(delim: "[",
	V_x;
	V_y
)
$

=== Трёхмерные графики функций

Мы будем давать функцию вида $y = f(x, z)$. Это потому что мы уже умеем рисовать графики $y = f(x)$ и нам остаётся лишь добавить сюда третью размерность. Таким образом $y$ будет зависеть ещё и от третьего измерния.

Как будем рисовать график? Возьмём параллельную плоскость $x O y$ и в ней у нас уже получится двумерный график --- некоторое сечение исходного графика. Это график поведения в плоскости $z = "const"$.

Область, которую мы хотим отрисовать, теперь имеет форму параллелепипеда. Для отрисовки мы будем использовать *алгоритм художника*.

Что делает художник? /*Ебашит Польшу, */Рисует сначала дальний план, затем ближний --- одно поверх другого/* и всё к Солнцу*/.

Мы с некооторой дискретизацией $z$ будем от самого удалённого значения $z$ рисовать сначала самый удалённый график, затем поближе и так далее.

Что мы будем в этом случае иметь в пространстве экрана? Окно, которое задаёт видимую часть графика на экране. При этом на деле мы будем рисовать графики размером поменьше: каждый график по дискретизации $z$ будет отрисовываться в рабочем окне, которое меньше исходной области видимости. Самый удалённый график находится в правом верхнем углу нашей исходной области видимости. Также, как мы по $x$ двигались попиксельно, нам нужно определить шаг движения по $z$. Для этого мы возьмём оставшееся после первого графика расстояние от его правого нижнего угла по $y$ до правого нижнего угла рабочей области и обозначим его за $W'_z$. Эта высота и есть количество графиков по $z$, которые нужно отрисовать.

Пространство графика задаётся вектором из точки $(V_(c x), V_(c y), V_(c z))$ в $(V_x, V_y, V_z)$.

В пространстве экрана получается, что мы каждый раз $(W_(c x) (z_0), W_(c y) (z_0))$ уменьшаем на единицу из-за попиксельного смещения.

$
	W_(c x) = W_(c x) - W_x + W'_x \
	W_(c y) (z_i) = W_(c y) (z_(i - 1) + 1) \
	W_(c y) (z_i) = W_(c y) (z_(i - 1) + 1) \
	W_(c x) (z_i) = W_()c x (z_i - 1) - Delta x \
	Delta x  (W_x - W'_x)/W_z \ \
$

// TODO: фото от Роба с матрицей вставить сюда








































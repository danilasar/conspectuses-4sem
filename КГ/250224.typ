= Лекция 3. 24 февраля 2024

// немного бухтим на тему того что было в предыдущей лекции

Для каждой точки с координатами $(x, y)$ применяем операцию кадрирования и получаем $(x', y')$, так же и с атрибутами

#image("imgs/007.png")

$
  x' = (x - V_(c x))/V_x dot W_x + W_(c x)
$
Так мы будем поступать всегда

Если мы хотим поиграться с нашим изображением

/ Афинные преобразования: ---

== Афинные преобразования

/ Перенос: был объект в одной системе координат, а мы хотим перейти к другому изображению, где этот объект будет перенесён, Будем сдивигать объект

#image("imgs/008.png")

Были вершины $(x_1, y_1)$ стали $(x'_1, y'_1)$

Были вершины $(x_2, y_2)$ стали $(x'_2, y'_2)$

Были вершины $(x_3, y_3)$ стали $(x'_3, y'_3)$

Сдвинули по $x$ на величину $T_x$

Сдвинули по $y$ на величину $T_y$

Точка $P(x, y)$ --- изначальная

Точка $P'(x', y')$ --- перенесенная

Перенос(параллельный перенос/сдвиг):

$
  x' = x + T_x\
  y' = y + T_y
$

/ Масштабирование относительно начала координат:

*Относительно --- та точка относителььно которой мы делаем преобразования остается на месте (относительно оси $x$ тянем все по $y$, а ось $x$ оставляем на месте)*

#image("imgs/009.png")

Пусть растягиваем в $2$ раза по $x$:
- то что было в $1$ станет в $2$
- $2$ превратится в $4$
- $3$ превратится в $6$

Пусть растягиваем в $1.5$ раза по $x$:
- то что было в $1$ станет в $1.5$
- $2$ превратится в $3$
- $3$ превратится в $4.5$

Масштабирование относительно начала координат:
$
  x' = x dot S_x\
  y' = y dot S_y
$

/ Поворот относительно начала координат против часовой стрелки на угол $theta$:

#image("imgs/010.png")

Перобразование заключается в:

Есть исходная система координат, исходный объект (можно представить что переходим в новую систему координат, при преобразовании)

Если соеденить лучем точку с началом координат

*Повернуть --- Повернуть этот отрезок относительно начала координат*

Из $P --> P'$ на угол $theta$ против часовой стрелки

Берем другую точку поворачиваем ее на угол $theta$ и тп.

Таким образом поворачиваем фигуру (треугольник в данном случае) против часовой стрелки

#image("imgs/011.png")

Вывод преобразования (поворота):
- Пусть длина отрезка $r$
- Пусть начальный угол $alpha$
- После преобразования угол $alpha + theta$
- Было:
  $
    cases(
      x = r cos alpha,
      y = r sin alpha
    )
  $
- Стало:
  $
    cases(
      x' = r cos (alpha + theta) = r cos alpha cos theta - r sin alpha sin theta = x cos theta - y sin theta,
      y' = r sin (alpha + theta) = r sin alpha cos theta + r sin theta cos alpha = y cos theta + x sin theta
    )
  $

Поворот относительно начала координат против часовой стрелки на угол $theta$:
  $
    cases(
      x' = r cos (alpha + theta) = x cos theta - y sin theta,
      y' = r sin (alpha + theta) = x sin theta + y cos theta
    )
  $

/ Зеркальное отражение: отрожаем относительно чего-то:
- Относительно начала координат
- Относительно оси $O_x$
- Относительно оси $O_y$

#image("imgs/012.png")

По факту масштабирование с коэффициентами $-1$ и $1$

Либо оба коэф = $-1$

Либо один коэф = $-1$, один коэф = $1$

== Совмещенные преобразования

Например, поворот на угол $theta$ против часовой стрелки относительно точки $A(x_a, y_a)$

#image("imgs/013.png")

Мы перейдем в новую систему координат с $x$ $y$ на $x^((1))$ $y^((1))$

Нужно из каждой точки изображения вычесть координаты точки $A(x_a, y_a)$

$
  cases(
    x^((1)) = x - x_a,
    y^((1)) = y - y_a
  )
$

$
  cases(
    x^((2)) = x^((1)) cos theta - y^((1)) sin theta,
    y^((2)) = x^((1)) sin theta + y^((1)) cos theta
  )
$

$
	cases(
		x' = x^((2)) + x_a = (x-x_a) cos theta - (y - y_0) cos theta + x_a,
		y' =  y^((2)) + y_a = (x - x_a) sin theta + (y - y_a) cos theta + y_a
	)
$

Компьютер --- тупая железка, поэтому обычно она формулами не занимается. Можно просто привести все преобразования к унифицированному виду. В этом нам помогут *матричные преобразования*.

== Матричные преобразования

Точку с координатами $(x, y)$ можно воспринимать как вектор из начала координат в эту точку // (не уверен в том что напимал ибо писал по памяти)

/ Вектор: --- сущность, которая имеет длину и направление

$
    cases(
        x = r cos theta,
        y = r sin theta
    )
$

Если у нас есть некоторая точка, мы можем принимать её как вектор-столбец, элементами которой являются координаты этой точки:

$
mat(delim: "[",
    x;
    y
)
$

$
mat(delim: "[",
    x';
    y'
) = M =  mat(delim: "[",
    x;
    y
)
$

$
mat(delim: "[",
	x'; y'
) = mat(delim: "[", a_(11), a_(12); a_(21), a_(22)) mat(delim: "[", x; y)
$


$
cases(
    x' = a_(1 1) x + a_(1 2) y,
    y' = a_(2 1) x + a_(2 2) y
)
$

$ x' = S_x dot x $
$ y' = S_y dot y $

_Примечание: для Миронова круглые и квадратные скобки эквивалентны._

$
mat(x'; y') = mat(S_x, 0; 0, S_y) mat(x; y)
$


$
cases(
    x' = x cos theta - y sin theta,
    y' = x sin theta + y cos theta
)
$

$
mat(x'; y') = mat(cos theta, - sin theta; sin theta, cos theta) mat(x; y)
$

В случае операции переноса всё значительно усложняется из-за наличия свободного члена в лице $T_x$ и $T_y$ $=>$ данная система матричных преобразований нас не удовлетворяет. Для решения возникших проблем мы введём понятие *однородных координат*.

/ Евклидовы координаты: привычные нам конкретные координаты точек.

/ Однородные координаты: касаются не только точек. Если мы говорим о произвольной сущности и её однородных координатах, то это набор чисел, заданный с точностью до общего множителя.

Переход от двухмерно евклидова пространства к трёхмерному однородному.

#image("imgs/014.png.png") // так и должно быть

Задали прямую:
$ A x + B y + C = 0 $

$ (A, B, C) == (2 A, 2 B, 2 C) $ // типа таже прямая


$ (x_1, x_2, x_3, ..., x_n) $

вводим $x_(n + 1)$ ...

$ (x_1 dot x_(n + 1), x_2 dot x_(n + 1), x_3 dot x_(n + 1), ..., x_(n+1)), x_(n + 1) eq.not 0 $

$ (x, y) =>^(alpha eq.not 0) (alpha x, alpha y, alpha) $

$ (chi_1, chi_2, ..., chi_n, chi_(n + 1)) => (chi_1/chi_(n + 1), chi_2/chi_(n + 1), ..., chi_n/chi_(n + 1)) $

$ (chi, gamma, alpha) => chi/alpha, gamma/alpha $

#image("imgs/015.png")

$
mat(delim: "[",
    chi';
    gamma';
    alpha';
) = mat(delim: "[",
    a_11, a_12, a_13;
    a_21, a_22, a_23;
    a_31, a_32, a_33
)
$

$
x' = a_11 x + a_12 y\
y' = a_21 x + a_22 y
$

$
chi' =  alpha x' = S_x dot x alpha = S_x dot chi\
gamma' =  alpha y' = S_y dot y alpha = S_y dot gamma
$

$ (x, y) =>^(alpha' = alpha) (x alpha, y alpha, alpha) $

$
chi' = x' dot alpha \
gamma' = y' dot alpha \
alpha'' = alpha
$


$
cases(
chi' = chi S_x = underline(a_(11) chi) + a_(12) gamma + a_(13) alpha,
gamma' = gamma S_y = a_(21) chi + underline(a_(22) gamma) + a_(23) alpha,
alpha' = alpha = a_(31) chi + a(32) gamma + underline(a_(33) alpha)
)
$

Отсюда вытекает матрица масштабирования:

$
mat(chi';gamma';alpha')=mat(s_x,0,0;0,s_y,0;0,0,1)=mat(chi,gamma,alpha)
$


$
    a x' = x cos theta - y sin theta\
    a y' = x sin theta + y cos theta
$ // не успел дописать сори

Матрица поворота:

$
mat(chi';gamma';alpha')=mat(
	cos theta, -sin theta, 0;
	sin theta, cos theta, 0;
	0, 0, 1
)=mat(chi,gamma,alpha)
$

Линейный перенос:

$
cases(
	x' = x + T_x,
	y' = y + T_y
)
=
cases(
	chi' = alpha x' = alpha x + T_x alpha,
	gamma' = alpha y' = alpha y + T_y alpha,
	alpha' = alpha
)
$

Отсюда матрица линейного переноса:

$
mat(chi'; gamma'; alpha')
=
mat(1, 1, T_x;
0, 1, T_y;
0, 0, 1)
mat(chi; gamma; alpha)
$



$
mat(delim: "[",
    chi';
    gamma';
    alpha
)
=
mat(delim: "[",
	1, 0, x_a;
	0, 1, y_a;
	0, 0, 1
)
mat(delim: "[",
	cos theta, -sin theta, 0;
	sin chi, cos chi, 0;
	0, 0, 1
)
mat(delim: "[",
    1, 0, - x_a;
    0, 1, - y_a;
    0, 0, 1
)
mat(delim: "[",
    chi;
    gamma;
    alpha
)
$

В силу ассоциативности мтриц мы можем совместить первую-третью матрицы в правой части равенства по правилу умножения матриц.

// пиздец 377 строк. я ебал
// НАМ ПИЗДААААААА



















Чтобы найти координаты вектора в новой системе координат, зная базис этой системы координат и координаты вектора p, то надо просто умножить скалярно вектор p на базис новой системы координат. Скалярное произведение вектора на единичный --- проекция на координатную ось.

$overline(p)' = mat(e_1^T'; e_2^T') overline(p)$ --- матрица в данном случае будет представлять собой матрицу поворота. Что интересно, если рассмотреть матрицу поворота: $mat(cos(theta), -sin(theta); sin(theta), cos(theta))$, то можно заметить, что длина каждой строки будет равна 1, а сама строка будет представлять собой единичный вектор в новой системе координат.

$x = e_1 * overline(p) \ 
y = e_2 * overline(p) \
z = e_3 * overline(p)$

$x' = e_1' * overline(p) \ 
y' - e_2' * overline(p) \ 
z' = e_3' * overline(p) \$

$"Rotate"_x(theta) = mat(1, 0, 0, 0;
0, cos(theta), -sin(theta), 0;
0, sin(theta), cos(theta), 0;
0, 0, 0, 1)$

$e_1' = (1, 0, 0) \
e_2' = (0, cos(theta), -sin(theta)) \
e_3' = (0, sin(theta), cos(theta))$

Модельная система координат --- локальная система координат, в которой располагаются точки каждой конкретной модели.

Мировая система координат --- система координат, которая вводится для того, чтобы каким-то образом привязать координаты моделей к общему виртуальному пространству, на котором они располагаются. Для перехода от модельной системы координат к мировой применяется модельное преобразование.

Но т.к. мировая система координат представляет собой общее виртуальное пространство, то не все модели, которые расположены в этом пространстве обязательно будет отображены на экране. Для того, чтобы отобразить некоторую модель именно в экране надо провести некоторые преобразования --- перенос общего изображения, масштибирование его. В наших лабораторных работах мы собираем все преобразования до операции кадрирования --- некоторая матрица М накопленных преобразований. Затем мы применяем матрицу кадрирования.

В трёхмерной графике мы применяем дополнительное преобразование.

= Система координат наблюдателя
В трехмерном мире нам нужен некоторый субъект, который будет нам говорить, что изобразить на экране. Потому что если у нас есть трехмерная система координат и трехмерные объекты, то нам нужно выяснить, как эти трехмерные объекты изображать на экране. Любое устройство вывода является двумерным, поэтому нужно от трехмерных объектов перейти к двумерным. Для этого нам нужно поставить некоторую точку зрения, из которой мы будем эти объекты наблюдать --- субъект наблюдателя (или же камера). Будем изображать только то, что видит наблюдатель. Чтобы определить, что он видит --- надо определить его позицию в трехмерном пространстве. Эту позицию будем называть *точкой наблюдения*. Очень важно, в какую сторону смотрит наблюдатель. Поэтому кроме точки, должен быть задан еще и *вектор наблюдения*. Этот вектор, если мы знаем точку наблюдения, можно задать, если задать точку, в которую смотрит наблюдатель (в таком случае вектором станет вектор, соединяющий эти две точки). Так же важно, как именно располагается наблюдатель (можно же наклонить голову), поэтому надо выбрать вспомогательный вектор вверх. Тогда эти два вектора будут задавать плоскость, которую видит наблюдатель. 

С наблюдателем будем связывать декартовую систему координат, которую будем называть системой координат наблюдателя. Её начало лежит в глазу наблюдателя, ось z направлена противоположно направлению наблюдения, но параллельно направлению наблюдения, ось y направлена вверх, ось x направлена вправо.

Пусть задана произвольная мировая система координат. Заданы точки S $(s_1, s_2, s_3) --- точка начала координат наблюдателя, P $(p_1, p_2, p_3)$--- точка, в которую смотрит наблюдатель. Вектор $overline(u)(u_1, u_2, u_3)$ задаёт направление вверх.

Чтобы перейти к системе координат наблюдателя. Вектор направления вверх не обязательно совпадает с осью y, он нужен лишь для определения плоскости. 

Чтобы перенести начало координат в точку s, применим матрицу: $mat(1, 0, 0, -s_1;
0, 1, 0, -s_2;
0, 0, 1, -s_3;
0, 0, 0, 1)$

$p_1' = p_1 - s_1 \
p_2' = p_2 - s_2 \
p_3' = p_3 - s_3 \$

Радиус вектор точки P теперь совпадает с вектором наблюдения. Ось z противоположна вектору наблюдения, поэтому у базисного вектора оси z будут координаты $e_3' = -overline(p)' / abs(overline(p)')$

У нас так же есть вектор u, который задает направление вверх. Если умножить его векторно на $e_3'$, то получится вектор, противоположный им, и который задаёт правую тройку векторов. $e_1' = (overline(u) crossmark e_3') / (abs(overline(u) crossmark e_3'))$

Ну и наконец $e_2' = (e_3' crossmark e_1') / abs(e_3' crossmark e_1')$.

Мы нашли три базисных вектора, поэтому перейдем к новой системе координат --- системе координат наблюдателя

$
  "Rotate" = mat(delim: "[",
    mat(e_1; e_2; e_3), mat(delim: #none, 0; 0; 0);
    mat(delim: #none, 0, 0, 0), mat(delim: #none, 1)
  )
$

Назовём переход к системе координат наблюдателя $"LookAt"(S, P, overline(u))$. Он будет совмещать перенос начало координат в точку S и поворот системы координат

$"LookAt(S, P, overline(u)) = mat(delim: "[",
    mat(e_1; e_2; e_3), mat(delim: #none, 0; 0; 0);
    mat(delim: #none, 0, 0, 0), mat(delim: #none, 1)
  ) mat(1, 0, 0, -s_1;
0, 1, 0, -s_2;
0, 0, 1, -s_3;
0, 0, 0, 1)$

Но пока мы никак не ограничивали наше изображение. В двумерной системе координат у нас был некоторый кадр, который мы размещали на экране. В трехмерной системе координат роль такого кадра будет выполнять *окно наблюдения*. Если у нас есть СК наблюдателя, то в ней мы введем специальную плоскость --- *экранную плоскость, или плоскость наблюдения*.

= Перспективная проекция

Перспектива --- намеренное искажение изображения с целью создания глубины.

В перспективном преобразовании точки переводятся в точки, прямые в прямые, но не все отрезки переводятся в отрезки. Перспективное преобразование --- не линейное.


В 6 лабораторной работе есть вопрос про то, почему стоя в середине куба у нас отображается
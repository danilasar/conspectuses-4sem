= Система координат наблюдателя
== Трёхмерное изображение
#image("imgs/056.png")
#image("imgs/057.png")
== Выбор точки наблюдателя
#image("imgs/058.png")
== Выбор направления наблюдателя
#image("imgs/059.png")
#image("imgs/060.png")
#image("imgs/061.png")
#image("imgs/062.png")
== Трёхмерное изображение
#image("imgs/063.png")
== Выбор направления вверх
#image("imgs/064.png")
#image("imgs/065.png")
#image("imgs/066.png")
== Параметры наблюдателя
#image("imgs/067.png")
== Система координат наблюдателя
#image("imgs/068.png")
#image("imgs/069.png")
== Вектор направления вверх
#image("imgs/070.png")
#image("imgs/071.png")
== Система координат наблюдателя
#image("imgs/072.png")
#image("imgs/073.png")
#image("imgs/074.png")


Все преобразования можно накапливать в единой матрице преобразований, как мы, собственно, и делаем в лабораторных работах. В результате перемножения матриц у нас получается матрица накопленных преобразований. Каждое преобразование мировой системы координат приводит к изменению матрицы, где накапливаются все преобразования.

Если мы хотим сделать анимацию, где передвигаются объекты в мировой системе координат, то у нас меняется матрица преообразований. Если будем менять $T_1$, значит, все точки перемножили, домножили на матрицу и сделали кадрирование.

Таким образом, у нас есть:
- Модельное преобразование, которое может меняться, но в наших лабах не меняется
- Преобразование какое-то ещё
- Преобразование кадрирования, которое отображает изображение на экран

$S R S T_n E$ --- это путь преобразований наших данных. В трёхмерном случае здесь добавляется дополнительное преобразование, связанное с тем, что на трёхмерную графику можно смотреть с разных сторон и трёхмерный мир требует наблюдателя, который за этим миром будет смотреть.

Нам нужен субъект, который будет говорить, что нам изобразить на экране.

Кроме точки наблюдения у нас ещё должен быть задан ещё и вектор наблюдения.

Понятно, что точка наблюдения и точка, в которую смотрит наблюдатель, не должны совпадать.

Также имеет значение угол наклона самого наблюдателя, поэтому мы должны ещё задать направление, в котором находится верх. Вектор верха и вектор наблюдения не обязательно перпендикулярны, а вместе они задают плоскость, в которой мы наблюдаем за миром. Плоскость наблюдения будет перпендикулярна направлению наблюдения.

//Внимание, анекдот
Внутри плоскости наблюдения мы введём *окно наблюдения*, в рамках которого будем ограничивать наше изображение. Изображение в нём будет двумерным (_мы считаем, что всё, что нарисовано за окном на самом деле нарисовано на окне_).

= Трёхмерные проекции
У нас появляется новая величина #strike(НИР) *near* --- расстояние от наблюдателя до окна наблюдения.

Координаты плоскости наблюдения: $z = -near$.


Перспективную проекцию мы используем с целью придания


В разные времена в разных культурах перспектива бывала разная, нам интересна более естественная двухточечная перспектива, с которой мы могли столкнуться, например, на черчении.

Стоит отметить: это первое нелинейное преобразование, которое мы для себя открыли, ведь здесь происходит деление на координаты. Чем это чревато?

Раньше у нас точки превращались в точки, прямые в прямые, отрезки в отрезки. Последнее особенно примечательно.

В перспективном преобразование всё немного не так. По-прежнему точки превращаются в точки, прямые в прямые, а вот отрезки в отрезки --- уже не всегда.

Если мы проецируем изображение, находящееся за нашей спиной, на камеру, то оно переворачивается. Но вот проблема: если отрезок начинается перед нами и уходит над головой куда-то назад, то изображение на окне будет искажено.
== Положение наблюдателя

// Сорян мой затуп

$ T(( L dot M ) dot P)_(2 times 2) $

Это все мы урезаем в квадрат $2 times 2$

То есть вот эта вот система у нас была и в двумерном случае.


$ T dot (F (T_r dot R o t dot T_r dot L dot M) dot P)_(2 times 2) $


Преобразование LookAt


Получается для каждой модели проекция и преобразования будут одинаковые

Только матрица $M$
// F
// я не могу найти эту презентацию....
// это что, 3д преобразования, проекции или что
// я тоже немного пропустил, хз


== Поворот на право

До поворота набл смотрел в точку $P (0, 0, -1)$ повернул по часовой стрелке по оси $O y$

$ M = #[Rotate] (overline(e_2), -theta) $
$ #[LookAt] ((0,0,0), M dot P, e_2) $

Если в обратную сторону
$ M = #[Rotate] (e_2, theta) $

Если наклоняет взгляд 


== Поворот вниз

#image("imgs/178.png") // это 42 строка

$
M = #[Rotate] (overline(e)_1 -theta) \
"LookAt"((0,0,0), M dot P, overline(e_1))
$

== Вращение против часовой стрелки

#image("imgs/179.png")

Если наблюдатель вращается относительно $O z$, то мы

$
M = #[Rotate] (overline(e_3), - theta)\
#[LookAt] ((0,0,0), M dot P, overline(e_3))
$

$M$ --- это матрица вращения, усечённая до третьего порядка (по умолчанию она 4x4, а мы берём 3x3, чтобы она была только для вектора)
// это 61 строка

== Вращение вокруг удаленной точки

#image("imgs/180.png")


$
M_1 = #[Translate] (0, 0, #[dist])\
M_2 = #[Rotate] (overline(e)_2, theta) \
#[LookAt] (M_1^(-1) M_2 M_1 dot P, (0, 0, -#[dist]), overline(e_2))
$

$
M = mat(
1,0,0,T_1;
0,1,0,T_y;
0,0,0,1
) \
P = M^(-1) M P
$

Матрица при вертикальном вращении в целом та же.

#imgae("imgs/181.png")

// норм? да я в 82 ты в 89 был вроде норм
$
M_1 = #[Translate] (0,0,#[dist]) \
M_2 = #[Rotate] (overline(e)_1, -theta) \
#[LookAt] (M_1^(-1) M_2 M_1 dot P, (0, 0, -#[dist]), overline(e)_2)
$

= Алгоритм Коэна-Сазарленда

_Реализовывать этот алгоритм не надо, но на экзамене ему будет посвящён один из вопросов_


В чем заключается алгоритм:

Мы имеем область видимости, и в этой области видимости есть набор отрезков. То есть, если область видимости задается как ..., то отрезки могут вылезать за области видимости. Есть алгоритмы, которые позволяют решать задачу отсечения не видимых отрезков.

Задача: Есть набор отрезков, а нам надо получить новый набор отрезков, который состоит только из видимых частей отрезков в области видимости


#image("imgs/182.png")

Из отрезка $A D$ должен остаться отрезок $C' A'$...

#image("imgs/183.png")


Такая задача распространенная. Она простая, когда область видимости --- прямоугольник. Сложно, когда выпуклый многоугольник или произвольный многоугольник (разбитое зеракало, дырка от выстрела в стене) // HACK: не дырка, а отверстие

// дед в 115 строке
// ко второй половине семестра мы изобрели протокол tcp
// проверяем корректность доставки пакетов

// я эту лекцию в феврале в записи смотрел
// ебейший алгоритм и притом реально простой

#image("imgs/184.png")

Обратим внимание на то, что область видимости делит наше пространство на 9 частей:
- Центральная часть
- Три области выше
- Три области снизу
- Три области слева
- Три области справа

_Примечание: множества пересекаются_

Итого одна центральная часть и 8 вокруг. Давайте присвоим каждой области четырёхзначный двоичный код.

#image("imgs/185.png")

Пусть биты имеют следующее значение:
+ Область слева?
+ Область справа?
+ Область снизу?
+ Область сверху?

Таким образом, правая нижняя область будет иметь код $0110$.


// я думаю, имеет смысл оставить эти формулы на картинке, без неё они бессмысленны

```c
// дальнейшие комментарии предполагают, что система координат правая
if(P.x < minX) { // точка левее области видимости
	code |= 1; // получаем единицу в первом разряде
} else if(P.x > maxX) { // точка правее области видимости
	code |= 2; // получаем единицу во втором разряде
}
if(P.y < minY) { // точка ниже области видимости
	code |= 4; // получаем единицу в третьем разряде
} else if(P.y > maxY) { // точка выше облатси видимости
	code |= 8; // получаем единицу в четвёртом разряде
}
```
// INFO: у Миронова в презентации +, но | более надёжно и уместно
// Ебать прикольно, а почему?
// Все живо, да?
#image("imgs/186.png")
// пиздец я тебе потом расскажу ты ахуеешь
// всё работает? я опять на 166
// все работает ты в 166, просто у меня секунд 30 твой текст не грузился, а потом прогрузился и все норм
// дед в 168
Обратим на закономерности со скриншота выше. С помощью битовых И, ИЛИ мы можем определять взаимное расположение точек. Есть, впрочем, неприятный нюанс:

#image("imgs/187.png")

У этих двух отрезков одинаковый результат битового И, но при этом виден из них только один.

#image("imgs/188.png")

// INFO: слушай, а типст регистрозависим? #image и #IMAGE —  это не одно и то же?
// хуй знает, вроде да, вроде зависим
// слава Богу

$
x_1 = min X
(? - y_1)/(y_2 - y_1) = (min x - x)/(x_2 - x_1) \

(y_1 - y_1)/(x_l - x_1) = (y_2 - y_1)/(x_2 - x_1) \

y_1 = y_1 + (x_1 -x_1)(y_2-y_1)/(x_2 - x_1) \
y_1 = y_1 + (min X - x_1)(y_2 - y_1)/(x_2 - x)1
$


Находим коды концов отрезка, тк логическое или дает, 0 мы его отбрасываем.

Потихоньку отсекаем хвосты и перевычисляем коды крайних точек:

#image("imgs/189.png")
#image("imgs/190.png")
#image("imgs/191.png")
#image("imgs/192.png")

Здесь по логическому И уже можно гарантировать видимость отрезка. Убедимся на другом примере:


#image("imgs/193.png")
#image("imgs/194.png")

ИЛИ не равно нулю, И тоже не равно нулю $=>$ у нас остался полностью невидимый отрезок, который мы целиком отбрасываем.

= Растеризация// я здесь 209


_Реализован не нами и мы его реализовывать не будем. Кодом нигде не прописаны, а реализованы предполагаемо в ходе каких-то операций_

Операторы ввода/вывода делятся на:
- растровые 
- векторные устройства --- предполагает, что выводятся ... (любое аналоговое изображение можно считать векторным)

/ Плоттер: устройство для отрисовки векторных изображений.

Изображения, как и устройства, делятся на растровые и векторные.


































// ниже этого коммента не пиши 


// Если что мне инф через Роба передавай












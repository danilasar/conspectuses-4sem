#let vec(n) = $overline(#n)$
= Двумерный поворот
#image("imgs/074.png")
Повернуть точку == переходим в новую систему координат

Тоже декартова система счисления, но она повернулась на угол $theta$. Предположим мы не знаем угол, но знаем базисный вектор системы координат $e_1' space и space e_2'$
Как узнать координаты точки $p(x, y)$. Проводим радиус вектор. В старой системе координат $overline(p) = (x, y)$. Как узнать координаты $p$в новой системе координат. Мы должны знать длину проекций $e_1'$ и $e_2'$. Так же сделать скалярное произведение 

$ e_1 dot p' $
$ e_2 dot p' $

$ e_1^T dot p' $
$ e_2^T dot p' $

$
overline(p)' = mat(delim: "[",
	e'^T_1;
	e'^T_2
) dot overline(p)
$

#image("imgs/075.png")

$
x = e_1 dot overline(p)\
y = e_2 dot overline(p)\
z = e_3 dot overline(p)
$

$
x' = e'_1 dot overline(p)\
y' = e'_2 dot overline(p)\
z' = e'_3 dot overline(p)
$

#image("imgs/076.png")
#image("imgs/077.png")

$
  "Rotate" = mat(delim: "[",
    mat(e_1; e_2; e_3), mat(delim: #none, 0; 0; 0);
    mat(delim: #none, 0, 0, 0), mat(delim: #none, 1)
  )
$

== Двойственность вращения
$
  "Rotate"_x = mat(
    1, 0, 0, 0;
    0, cos theta, -sin theta, 0;
    0, sin theta, cos theta, 0;
    0, 0, 0, 1
  )
$

$
  vec(e)'_1 = mat(1, 0, 0) \
  vec(e)'_2 = mat(0, cos theta, - sin theta);
  vec(e)'_3 = mat(0, 0, 0, 1)
$


#grid(columns:3, 
$
|e'_1| = 1\
e'_1 dot e'_2 = 0\
e'_1 times e'_2 = e'_3
$,
$
|e'_2| = 1\
e'_1 dot e'_3 = 0\
e'_2 times e'_3 = e'_1
$,
$
|e'_3| = 1\
e'_2 dot e'_3 = 0\
e'_3 times e'_1 = e'_2

$,
$
  |vec(e)'_3| = 1 \
  vec(e)'_2 dot vec(e)'_3 = 0 \
  vec(e)'_3 times vec(e)'_1 = vec(e)'_2
$
)

= Система координат наблюдателя
Принцип, который будет проходить от третьей лабораторной и до последней, заключается в следующем: у нас задан набор данных (координаты с какими-то атрибутами --- наборы отрезков, наборы треугольников...) --- то есть мы так или иначе перечисляем вершины, заданные в своей системе координат.

Допустим, у нас несколько моделей, каждая задана в своей локальной системе координат и для каждой задан свой набор вершин в ней.

#image("imgs/078.png")

Для каждой можели у нас есть своя матрица преобразований $T_i$, которая позволяет определить положение модели в мировой системе координат --- системе координат нашего виртуального мира.

// формулы к описанию получения картинки в другой ск
$ T_1 dot p_1 $
$ T_1 dot p_2 $

Дальше мы, выполняя операцию кадрирования, определяем экранную систему координат и отображаем в неё видимую часть виртуального мира.
$
R space S space T r space T_1 dot p_1\
R space S space T r space T_1 dot p_2
$

#image("imgs/079.png")

Все преобразования можно накапливать в единой матрице преобразований, как мы, собственно, и делаем в лабораторных работах. В результате перемножения матриц у нас получается матрица накопленных преобразований. Каждое преобразование мировой системы координат приводит к изменению матрицы, где накапливаются все преобразования.

Если мы хотим сделать анимацию, где передвигаются объекты в мировой системе координат, то у нас меняется матрица преообразований. Если будем менять $T_1$, значит, все точки перемножили, домножили на матрицу и сделали кадрирование.

Таким образом, у нас есть:
- Модельное преобразование, которое может меняться, но в наших лабах не меняется
- Преобразование какое-то ещё
- Преобразование кадрирования, которое отображает изображение на экран

$
underbracket(underbrace(dots space R space S space T r, S space R space S space T r space E ), M)
$

$S R S T_n E$ --- это путь преобразований наших данных. В трёхмерном случае здесь добавляется дополнительное преобразование, связанное с тем, что на трёхмерную графику можно смотреть с разных сторон и трёхмерный мир требует наблюдателя, который за этим миром будет смотреть.


Нам нужен субъект, который будет говорить, что нам изобразить на экране.

== Трёхмерное изображение

Нам по сути необходимо перейти от трёхмерных объектов к двумерным, чтобы изобразить их на нашем двумерном устройстве.

/ Наблюдатель: (камера) --- субъект, который будет отвечать за отображение на экран.

Мы через наблюдателя смотрим на трехмерный объект и он становится двумерным

Наблюдатель имеет свойства той же самой камеры: она рисует то, что видит. Если считать себя наблюдаетелем, то мы по сути смотрим во внешний мир через окно. Для нас сцена за окном --- то, что "нарисовано" на окне.

Мы к этому перейдём, но пока что мы фиксируем субъекта нашей трёхмерной сцены и будем называть его наблююдателем. Мы будем изображать то, что он видит, и это будет зависить от положения глаза наблюдателя.

Уточним, мы считаем, что наблюдатель имеет только один глаз.
// HACK: наблюдатель выбрал вилкой в глаз

#image("imgs/056.png")

У нас есть *точка наблюдения* --- точка, из которой наблюдатель смотрит во внешний мир.

Верктор наблюдения можем задать через: от точки наблюдения до точки объекта

#image("imgs/057.png")
== Выбор точки наблюдателя
#image("imgs/058.png")
== Выбор направления наблюдателя
Кроме точки наблюдения у нас ещё должен быть задан ещё и вектор наблюдения.

Понятно, что точка наблюдения и точка, в которую смотрит наблюдатель, не должны совпадать.

#image("imgs/059.png")
#image("imgs/060.png")
#image("imgs/061.png")
#image("imgs/062.png")
== Трёхмерное изображение
#image("imgs/063.png")
== Выбор направления вверх

Также имеет значение угол наклона самого наблюдателя, поэтому мы должны ещё задать направление, в котором находится верх. Вектор верха и вектор наблюдения не обязательно перпендикулярны, а вместе они задают плоскость, в которой мы наблюдаем за миром.

#image("imgs/064.png")
#image("imgs/065.png")
#image("imgs/066.png")
== Параметры наблюдателя
/ Система координат наблюдателя: --- правая декартова система коорднат,
- ???
- Ось Z направлена противоположно направлению наблюдения, но параллеьная ему
- Ось X направлена вправо
- Ось Y направлена вверх.
#image("imgs/067.png")
== Система координат наблюдателя
#image("imgs/068.png")
#image("imgs/069.png")
== Вектор направления вверх
#image("imgs/070.png")
#image("imgs/071.png")
== Система координат наблюдателя
Следующее преобразование --- это переход в систему координат наблюдателя из мировой системы координат.

Пусть:
- $P (p_1, p_2, p_3)$ --- точка, в которую смотрит наблюдатель
- $overline(u) (u_1, u_2, u_3)$ задаёт направление вверх для наблюдателя
- $S (s_1, s_2, s_3)$ --- положение наблюдателя
#image("imgs/072.png")
#image("imgs/073.png")
#image("imgs/074.png")

Кроме переноса у нас будет ещё и вращение системы координат. С переносом никаких проблем нет:

$
mat(delim: "[",
	1, 0, 0, -s_1;
	0, 1, 0, -s_2;
	0, 0, 1, -s_3;
	0, 0, 0, 1;
)
$

#image("imgs/080.png")
$
p'_1 = p_1 - s_1
p'_2 = p_2 - s_2
p'_3 = p_3 - s_3
$

// e_3 появился
#image("imgs/081.png")
У базисного третьего вектора у нас будут координаты
$
vec(e)'_3 = (- vec(p)')/(|vec(p)'|)
$

У нас есть вектор $u$, задающий вектор вверх.
#image("imgs/082.png")
Если мы помножим на $vec(e)'_3$, у нас получится вектор, смотрящий туда, куда долна смотреть ось $x$. А если разделить на длину, то получится базисный вектор $vec(e)'_1$. Осталось найти $vec(e)'_2$

#image("imgs/083.png")
#image("imgs/084.png")
$
  vec(e)'_1 = (vec(u) times e'_3)/(|vec(u) times e'_3 |)\
  vec(e)'_2 = (e'_3 times e'_1)/(|e'_3 times e'_1|)\
  vec(e)'_3 = (- vec(p)')/(|vec(p)'|)
$
== Преобразование LookAt
#image("imgs/085.png")
#image("imgs/086.png")
_осторожно, опечатка: единицы оказались не по диагонали_

$
vec(e)'_1 = frac(vec(u) times vec(e)'_3, |vec(u) times vec(e)'_3|) \
vec(e)'_2 = (e'_3 times e'_1)/(|e'_3 times e'_1|)\
vec(e)'_3 = frac(-vec(p)', |vec(p)'|)$ 

$
  mat(
    chi';
    gamma';
    xi';
    alpha'
  ) = mat(delim: "[",
    mat(e_1; e_2; e_3), mat(delim: #none, 0; 0; 0);
    mat(delim: #none, 0, 0, 0), mat(delim: #none, 1)
 ) mat(delim: "[",
  1, 0, 0, -s_1;
  0, 1, 0, -s_2;
  0, 0, 1, -s_3;
  0, 0, 0, 1
 ) mat(
    chi;
    gamma;
    xi;
    alpha
  )
$

$
  "LookAt"(S, P, vec(u)) = mat(delim: "[",
    mat(e_1; e_2; e_3), mat(delim: #none, 0; 0; 0);
    mat(delim: #none, 0, 0, 0), mat(delim: #none, 1)
 ) mat(delim: "[",
  1, 0, 0, -s_1;
  0, 1, 0, -s_2;
  0, 0, 1, -s_3;
  0, 0, 0, 1
 )
$

Плоскость наблюдения перпендикулярна направлению наблюдения. Она перед наблюдателем, то есть плоскость имеет уравнение $Z = - alpha$, где $alpha$ --- какое-то число.

#image("imgs/087.png")

Всё, что находится дальше плоскости наблюдения, названной *окном наблюдения* --- то, что мы видим. Всё, что находится за окном, мы рисуем на окне и изображение с окна мы выводим на двумерный экран.
Следующий вопрос с этим связанный это проекци

#image("imgs/088.png")

= Трёхмерные проекции

#image("imgs/089.png")

/ near: --- растояние от наблюдателя до окна наблюдения

Окно наблюдения --- кадр

Наблюдатель смотрит в центр окна

== Прямоугольная проекция (ортоганальная) 

Взяли откинули $z$ у каждой точки заменили на $-n e a r$

$ z = - n e a r $
$
(x_1, y_1, - n e a r)
$

#image("imgs/090.png")

== Перспективная проекция
/ Перспектива: --- это намеренное искажение изобразжения с целью придания глубины

В разные времена в разных культурах перспектива бывала разная, нам интересна более естественная двухточечная перспектива, с которой мы могли столкнуться, например, на черчении.

$
(x'_1, y'_1, - n e a r)
$

// HACK: Картинка из звездалета звездных войн с минимальным кол-вом полигнов))))
Одноточечная перспектива:
#image("imgs/091.png")
Двухточечная перспектива:
#image("imgs/092.png")

#image("imgs/093.png")

На окне можем найти каждую точку изображения за окном:

Соединяем глаз наблюдателя с точкой за окном

#image("imgs/094.png")

$
  frac(y'_1, "near") = frac(y_1, -z_1)
$

$y'_1$ относится к $"near"$ (расстояние) также, как $y_1$ относится к $-z_1$ (координата). Мы это имеем из подобия треугольников.

#image("imgs/095.png")

Оттуда же выведем, чему равны конкретные координаты:

$
  x'_1 = "near" frac(x_1,(-z_1))\
  y'_1 = "near" frac(y_1,(-z_1))
$


$
  x' = "near" frac(x, -zeta), \
  y' = "near" frac(y, -zeta)
$

#image("imgs/096.png")

$
  x' = (chi')/(alpha'), \
  y' = (gamma')/(alpha')
$

Построим матрицу:

$
  mat(delim: "[",
    chi'; gamma'; zeta'; alpha'
  ) = mat(delim: "[",
    n e a r, 0, 0, 0;
	  0, n e a r, 0, 0;
	  0, 0, 0, 0;
	  0, 0, -1, 0
  ) mat(delim: "[",
    x; y; z; 1
  )
$
_В третьей строке матрицы на самом деле на третью позицию можно поставить что угодно, т.к. у нас фактически происходит деление на -z при переходе из однородных координат в евклидовы_
$
  -alpha' = -z'
$

Стоит отметить: это первое нелинейное преобразование, которое мы для себя открыли, ведь здесь происходит деление на координаты. Чем это чревато?

Раньше у нас точки превращались в точки, прямые в прямые, отрезки в отрезки. Последнее особенно примечательно.

В перспективном преобразование всё немного не так. По-прежнему точки превращаются в точки, прямые в прямые, а вот отрезки в отрезки --- уже не всегда.

Если мы проецируем изображение, находящееся за нашей спиной, на камеру, то оно переворачивается. Но вот проблема: если отрезок начинается перед нами и уходит над головой куда-то назад, то изображение на окне будет искажено.

/// о здаова
/// хы
// отрезок без прямой:
#image("imgs/097.png")
// отрезок с прямой:
#image("imgs/098.png")

// прямая без отрезка:
#image("imgs/099.png")
// ЕЕЕЕЕЕЕЕЕЕЕЕЕЕЕЕ 100 
#image("imgs/100.png")
// ДЕДУ СОТКА ОТГРАХАЛА
// я даже не знаю, праздновать или хоронить?
// HACK: Будто на лекции по физике сижу, на теме про линзы)))
// ОООО магниты пошли))))

Следующие проеции мы рассмотрим на следующих парах.

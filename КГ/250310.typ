= Лекция 5. 10 марта 2025.

// HACK:
// СОСААААААААААААААААААААААААТЬ
// СОСААААААААААААААААААААААААТЬ
// КООП 4 ИГРОКА left 4 dead 
// АХХАААХАХХААХАХААХ
// Эта лекция набухнет от подключений
// ГООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООЛ


// HACK: Евросоюз желает иметь Украину своим членом.

// Начало здесь. "Оставь надежду всяк сюда входящий"

= Операции над векторами

Вектор = Длина + направление

dsТа


// TODO: Следите у кого где курсор

Мы оперируем свободными векторами. У вектора есть длина и направление.

Как можно задать направление у двумерного вектора.

Мы откладываем 

Угол измеряем в положительном направлении (против часовой стрелки). Мы использовали полярные координаты (точка и одна ось, точка задаётся парой: радиус и угол). Мы их используем лишь косвенно. Пусть есть левая и правая СК. Пусть имеется точка $P(x, y)$. 

$ (r, phi) $ 

//FIX: #image(source: "imgs/016.png")

Вектор, соединяющий начало СК и точку $P$ будем называть радиус вектором точки $P$.

--- все точки в пространстве задаются такой парой, где $r$ --- радиус, а $phi$ --- угол

Пусть у нас есть точка $P(x,y)$ и вектор от начала координат, до этой точки.
Мы можем определить вектор исходящий из начала координат в точку $P$, у него есть длина и угол с осью $O x$, такой вектор будем называть радиус-вектором точки $P$. Обозначается $p$.

$ overline(p) $

Любой свободный вектор можно представить, как радиус-вектор этой точки. Любой радиус вектор можно задать координатами той точки, радиус вектором которой он является.

$ overline(p) = (r, phi) $

Если мы знаем что привязка вектора к точке $(0, 0)$.

// pizda

Если мы знаем, что вектор задан, то его координаты можно представить как:
$
	overline(p) (r, phi)\
	x = r cos phi\
	y = r sin phi
$

// FIX: #image("imgs/017.png")

// Здесь Миронов указывает на проекции радиус-вектора на оси координат

Из координат радиус-вектора можно выразить его длину, угол к оси $O x$. 

// FIX: #image("imgs/018.png")

Пусть имеется два вектора:

$ overline(u) " и " overline(v) #[ заданным, тогда] $

$overline(u) + overline(v)$

Суммой двух векторов будет вектор, началом которого является начало координат, а концом --- конец вектора $overline(v)$, при условии, что начало вектора $overline(v)$ находится на конце вектора $overline(u)$, начало которого является началом координат.

Вектора заданы как:

$ overline(u) = (u_x, u_y) $

$ overline(v) = (v_x, v_y) $

К ним применимы операции:

$ overline(u) + overline(v) = (u_x + v_x, u_y + v_y) $
$ overline(w) =  overline(u) - overline(v) <=> overline(u) = overline(w) + overline(v) $

Разностью двух векторов $overline(u) $ и $overline(v)$ будет вектор, началом которого будет конец вектора $overline(v)$, а концом --- конец вектора $overline(u)$.


$ overline(u) - overline(v) = (u_x v_x, u_y - _y) $// FIX: #image("imgs/019.png")

$ overline(u) space k gt 0 $
$ k overline(u) $
$ k overline(u) = (k u_x, k u_y) $

// FIX: #image("imgs/020.png")

Сдвигать вектор нельзя, т.к. у него нет позиции в пространстве.
// HACK:
// у тебя Е слетела 
// у тебя Е перенос строки сли
// Е- Это кому?
// - Это не у меня
в координатсахл ипово имеется некоторый вектор, у которого есть длина $R$, угол $phi$, тогдарот вектора будет заключатся в прибавлении к значению угла $phi$ угол $theta$.

$ P(x, y) = (v_x, v_y) $
$overline(P) = (v_x cos(theta) - v_y sin(theta), v_x sin(theta) + v_y cos (theta))$

//FIX: #image("imgs/021.png")


Скалярным произведением называется величина, которая равна:

$ overline(u) dot overline(v) = |overline(u)| dot |overline(v)| cos limits((overline(u) overline(v)))^angle $

$ |overline(u)| = r $ --- длина вектора $overline(u)$

Стоит вернуться к представлению вектора через координаты.

Пусть у нас имеется декартова система координат:

Мы можем найти проекцию вектора $overline(u)$ на ось $o x$.

// FIX: #image("imgs/022.png")

$overline(u)_x$ --- проекция на ось x.

Обозначим эту проекцию как вектор $overline(u)_x$
 
По аналогии обозначим проекцию на $o y$ как $overline(u)_y$

$ overline(u) = overline(u)_x + overline(u)_y $

Скалярное произведение двух векторов будет равно:
$ overline(u) overline(v) = (overline(u)_x + overline(u)_y) dot (overline(v)_x + overline(v)_y) $

// HACK: Когда сомалийские пираты потребовали выкуп за украинское судно, в Газпроме смеялись до слёз
// КАКОЙ УЕБАН У МЕНЯ БАТАРЕЮ ПОСТАВИЛ АААААААААААа ЕБАНЫЙ ОТОПИТЕЛЬНЫЙ СЕЗОН
// ЗЕНИТНУЮ
// АРТИЛЛЕРИЯ
// - Переодически нужно пострадывать
// - БОСАНАНСКА БЕКРИЯ
// - АРТИЛЕРИЯ
// - БОСАНАНСКА БЕКРИЯ
// - ЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭЭээ
// - МОЯ БОСНА ПОРОДОСНАААААА

// FIX: #image("imgs/023.png")

$ |e_1| = 1 $

$ |e_2| = 1 $

$ overline(u)_x = |overline(u_x)| * overline(e_1) $  

По аналогии вектор $overline(u)_y$ можно записать:

$ overline(u)_y = |overline(u_y)| * overline(e_2) $  

Начнем пользоваться:
// Быстро и мощно

// ща

// TODO: FIX THIS SHIT IN 1 LINE
$
	overline(u) overline(v) = (|overline(u_x)| * overline(e_1) + |overline(u_y)| * overline(e_2)y) dot (|overline(v)_x| e_1 + |overline(v)_y| e_2)= \
	= (|u_x| e_1 + |u_y| e_2) dot (|v_x| e_1 + |v_y| e_2) =\
	= |u_x| |v_x| e_1 e_1 + |u_x| dot |v_y| e_1 dot e_2 +\
	+ |u_y| |v_x| e_2 e_1 + |u_y| dot |v_y| e_2 dot e_2 = \
	= |u_x| |v_x| + |u_y| |v_y|
$
// верни первую строку как было блять
// ты куда блять верни 
// пиши левую я правую буду
// HACK:
// - Нифига ты кудесник


// HACK: Укранские вегетерианцы доказали, что сало --- это растение
// Данилин вклад бесценен
// хули палишь
// Джесси, як должни варiть сало
// Дякую Мiстер Уайт
Одинаковые базисные векторы:
$ e_1 dot e_1 = |e_1||e_1| cos(e_1 e_1) = 1 $
Gроизведение разных базисных векторов:
$ e_1 dot e_2 = |e_1||e_2| cos(e_1 e_2) = 0 $
// ДА БЛЯТЬ ЕСТЬ ЖЕ УЖЕ

Длина проекции:

$ overline(u) dot overline(v) = | overline(u)_x| | overline(v)_x | + | overline(u)_y | | overline(v)_y | $
//|overline(u_x)| * overline(e_1)
Если $overline(u) = (u_x, u_y), overline(v) = (v_x, v_y)$

$
	overline(u) = (u_x, u_y)\
	overline(v) = (v_x, v_y)\
	overline(u) = (u_x, u_y), overline(v) = (v_x, v_y) 
$

#let vec(v) = $overline(#v)$
// да блять
// пишите как есть
$ vec(t) $
// чекайте, работает?
// Нихуя
// теперь работает, дед пофиксил

== Геометрический смысл скалярного произведения

$ |overline(u)| = r $

Пусть есть вектор $overline(u)$ и единичный вектор $overline(i)$. Проекцией вектора $overline(u)$ на вектор $overline(i)$ назовем:

$ overline(u) dot overline(i) = |overline(u)|overline(i)| cos(overline(u)overline(i)) = |overline(u)| cos limits((overline(u)overline(i)))^angle $

В пендосии скалярное произведение называется dot-product.

// FIX: #image("imgs/024.png")

Наряду со скалярным произведением в ддвумерном случае существует также *псевдоскалярное произведение*

// У КРЕСТ В В КРЕСТ КРЕСТ В++

Если есть два вектора $overline(u)$, $vec(v)$, 
то псевдоскалярным произведением обозначим:
$overline(u) times overline(v)$

$ overline(u) times overline(v) = |overline(u)| dot |overline(v)| sin angle overline(u) overline(v) $
// NOTE: используй vec
$ vec(u) times vec(v) = - vec(v) times vec(u) $

В пендосии называется cross-product.

*ВАЖНО: МИРОНОВ НАЕБАЛ. CROSS-PRODUCT --- ЭТО ВЕКТОРНОЕ ПРОИЗВЕДЕНИЕ, А SKEW PRODUCT --- ПСЕВДОСКАЛЯРНОЕ*
// HACK: ТРАМП ТАК СКАЗАЛ.

// ЭТО НЕ CROSS PLATFORM

$ e_1 times e_1 = 0 $

$ e_1 times e_2 = 1 $
$ e_2 times e_1 = |e_1| dot |e_2| dot -1  = - 1 $
$ e_2 times e_2 = 0 $ 

$
	overline(u) times overline(v) = (u_x e_1 + u_y e_2) times (v_x e_1 + v_y e_2) =\
	= u_x v_x (e_1 times e_2) + u_x v_y (e_1 times e_2) +\
	+ u_y v_x (e_2 times e_1) + u_y v_y (e_2 times e_2) =\
	= u_x v_y - u_y v_x = overline(u) times overline(v)
= mat(delim: "|",
    u_x, u_y;
    v_x, v_y
)
$

// HACK: Только в Веховной раде можно по-русски обматерить за то, что кто-то не говорит по-украински.

Если мы хотим повернуть вектор, мы используем обычную матрицу перехода 2 x 2:

$ mat(delim: "[",
x';
y'
)

= mat(delim: "[",
    cos theta, - sin theta;
    sin theta, cos theta
)

mat(delim: "[",
	x;
	y;
)

$

// HACK: - Так в Украину или на Украину?
//       - Желательно в объезд
// Подъезд

== 3D вектор

Добавляем 3-ю ось так, чтобы она смотрела "на нас", таким образом система координат останется правой. 3-я ось --- ось $O z$
// не сломалось? Тема? Заебись всё.
$ O x, O y, O z $
// - Нет
// - Ок

Если ось $O z$ смотрит "против нас", то у нас ось координат станет левой

// #image("imgs/025.png")
// #image("imgs/026.png")
// Это есть на портале Course SGU начиная с этой лекции

Для вектора $vec(u)$ можно отложить проекцию на каждую из осей.
$ u_1 = |vec(u)| cos gamma_1 $
$ u_2 = |vec(u)| cos gamma_2 $
$ u_3 = |vec(u)| cos gamma_3 $

_Зарисовки можно найти в презентациях Миронова на курсе_

// FIX: #image("imgs/027.png")

$ 
vec(u) 
 = mat(delim: "[",
    u_1;
    u_2;
    u_3;
 )
= mat(delim: "[",u_1, u_2, u_3)^T
= (u_1 u_2 u_3)
$
$ |vec(u)| = sqrt(u_1^2 + u_2^2 + u_3^2) $
// HACK:
// Эль Гандонио пиздит мои строкиё
// - не пон?
// Не тебе 
// - Ok



$ 
k vec(u) 
 = mat(delim: "[",
    k  u_1;
    k u_2;
    k u_3;
 )
= mat(delim: "[",k u_1, k u_2, k u_3)^T
= (k u_1 k u_2 k u_3)
$

// да, забей это пиздец он проспидранил слайды
// ЫАААААААААААААААААААААААААААААjj 
// Где дед


$ vec(u) = vec(u)_1 + vec(u)_2 + vec(u)_3 $
$ vec(u) = vec(u)_1 e_1 + vec(u)_2 e_2 + vec(u)_3 e_3 $ // TODO: Так, да?
// Да
$
vec(u) dot vec(v) = |vec(u)| |vec(v)| cos gamma\
vec(u) dot vec(v) = u_1 v_1 + u_2 v_2 + u_3 v_3\
vec(u) dot vec(v) = mat(delim: "[",
	u_1, u_2, u_3
) mat(delim: "[", 
	v_1;
	v_2;
	v_3
) = vec(u)^T vec(v)
$
$ vec(v) dot vec(u) = mat(delim: "[", v_1, v_2, v_3) mat(delim: "[", u_1; u_2; u_3) = vec(v)^T vec(u) $
// Пиздец на слайде
// - Я ливаю


/* HACK: Еврей спрашивает жену:
-- Что тебе подарить на день рождения?
-- Право, Мойша, я даже не знаю...
-- Хорошо, даю на размышления ещё год.*/
// - Danya just casually dropped another bomb и пошёл дальше по делам

== Векторное произведение

Векторное произведение определяетя следующим образом:

// FIX: #image("imgs/028.png")

На данном этапе соглашение о направлении угла не имеет смысла, будь то против или по часовой стрелкам. Поэтому угол $gamma$ просто называется углом между $vec(u)$ и $vec(v)$.

$ vec(w) = vec(u) times vec(v) $
$ |vec(u) times vec(v) | = |vec(u)| |vec(v)| sin(angle(gamma)) $
// HACK:
// поставь доллар еб твою мать
// - Это ты то говоришь?)
// я не сижу без дела с открытм долларом блять 
// - хаххахк
// Жадность php разработчиков безгранична, поэтому они обожают доллары
// <?php $my_var = 69; echo $my_var ?>
// ВЫ ЧЕ ПООХУЕВАЛИ БЛЯЯЯЯЯЯЯТЬ
$ vec(w) perp vec(u) <=> vec(w) dot vec(u) = 0 $

$ vec(w) perp vec(v) <=> vec(w) dot vec(v) = 0 $

$ vec(u) times vec(v) = - (vec(v) times vec(u)) $
Если отмеряем против часовой стрелки то он будет больше 180, но нужно мерить в другую сторону, чтобы получить положительный синус

//HACK: --- Какая самая обидная фамилия для хохла?
//      --- Москаленко
/// Хохла спросить забыли 

// Вы заметели, что кол-во мемов больше чем лекции
// Похуй
// 13:23 *Миронов закрыл дверь*
// 13:24 *в аудитории погас свет*
// 13:25 БЛЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯТЬ

// 
// ZZZZZZZZZZ я сплю
// OOOOOOOOOO
// VVVVVVVVVV




Мы говорим, что будем откладывать ... из точки

Резуьтат отрицательный // TODO: дальше текст проебан блять

// Да пиши че он говорит блятть это полезнее
// 13:25 Миронов черканул маркером вниз
Если брать угол больше 180 то направление станет отрицательным

// FIX: #image("imgs/029.png")
// FIX: #image("imgs/030.png")


Надо, чтобы эти три вектора образовывали "тройку": $vec(u) space vec(v) space vec(w)$.

$ vec(u) space vec(v) space vec(w) $
// 13:28 Миронов поднял и опустил экран
// 13:28 Миронов: Эммм....

$ vec(w) = vec(u) times vec(v) $ 
$ |vec(v) times vec(u)| = |vec(v)| |vec(u)| sin angle gamma $
$ vec(w) perp vec(u) <=> vec(w) dot vec(u) = 0 $

$ vec(w) perp vec(v) <=> vec(w) dot vec(v) = 0 $

$ vec(u) times vec(v) = - (vec(v) times vec(u)) $

Так как у нас три оси, то и три базисных вектора, 9 различных сочетаний векторного произведения базисных векторов.

#let arr = (
	(1, 2, 3),
	(2, 3, 1),
	(3, 1, 2),
	(2, 1, -3),
	(3, 2, -1),
	(1, 3, -2),
	(1, 1, 0),
	(2, 2, 0),
	(3, 3, 0)
)
#let arr2 = ()

#for equation in arr {
	arr2.push(
	$
		e_#equation.at(0) times e_#equation.at(1) =
			#if (equation.at(2) != 0) {
				if(equation.at(2) < 0) { $-$ }
				$e_#calc.abs(equation.at(2))$
			} else { $0$ }
	$)
}
#table(columns: 3, stroke: none, ..arr2)

// HACK: АБАЮНДА НАХУЙ


$
	vec(u) times vec(v) = (u_1 e_1 + u_2 e_2 + u_3 e_3) times (v_1 e_1 + v_2 e_2 + v_3 e_3)
$



$ vec(u) times vec(v) = mat(delim: "|",
e_1, e_2, e_3;
u_1, u_2, u_3;
v_1, v_2, v_3;
)
$

$
vec(u) times vec(v) = M vec(v) = mat(delim: "[",
	a_11, a_12, a_13;
	a_21, a_22, a_23;
	a_31, a_32, a_33
) = mat(delim: "[",
	v_1;
	v_2;
	v_3
)
$

$
vec(u) times vec(v) = M vec(v) = mat(delim: "[",
	0, a_12, a_13;
	a_21, a_22, a_23;
	a_31, a_32, a_33
) = mat(delim: "[",
	v_1;
	v_2;
	v_3
)
$
$ vec(u) times vec(v) = M vec(v) = mat(delim: "[",
0, -u_3, u_2;
u_3, 0, -u_1;
-u_2, u_1, 0
) mat(delim:"[",
v_1;
v_2;
v_3)
$

$
[vec(u)] = mat(delim: "[",
	0, a_12, a_13;
	a_21, a_22, a_23;
	a_31, a_32, a_33
) 
$

$ [vec(u)]_x  =
mat(delim: "|",
    0, -u_3 u_2;
u_3, 0, -u_1;
// TODO: Дописать
)
$























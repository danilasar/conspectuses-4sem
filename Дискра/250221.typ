= Лекция 2. 21 февраля 2025

Основные правила комбинаторики

1. *Правило произведения*: после выбора A-m можно выбрать B-n $=>$ $(A, B)$ --- $m n$

2. *Правило суммы*: вместе можно выбрать A-m  и B-n $=> (A, B)$ --- $m + n$

/ Размещения с повторениями из $n$ типов по k элем: называются все таки комбинации из k элем, котор отлич друг от друга порядком следования или составом элементов

$ overline(A)^k_n = n^k $

_Примечание:_ $n$ и $k$ в любом соотношении.

/ Размещения без повторений  из n различных элементов по k элементов: назыв все различные комбинации из k элемемнтов, выбранных из n исходных элементов, которые отличаются друг от друга порядком следования элементов

$ overline(A)^k_n = (n!)/((n - k)!) = n(n - 1) ... (n - k + 1) $

Доказывается элементарно с использованием правила произведения. Выше формула расписана.

/ Перестановками: из $n$ элементов называются все возможные последовательности из этих $n$ элементов. Другими словами, когда мы говорим о перестановках, мы выкладываем в ряд $n$ элементов и получаем перестановку. Меняем порядок --- получаем новую перестановку.

$ P_n = n! $

/ Перестановки без повторений: Если среди n элементов нет повторяющихся, то перестановки наз перестановками без повторений

$ overline(P) (n_1, n_2,..., n_k), space n_1 + n_2 + ... + n_k = n $


// вчера сестра звонит папе и спрашивает: что в математике значат 4 восклицательных знака?
// она имела ввиду 4!

// АХАХАХАХАХХААХХАХХАХАХАХАХА 
/ Количество перестановок с повторениями: $overline(P)(n_1, dots, n_k) = ((n_1 + n_2 + ... + n_k)!)/(n_1! n_2! ... n_k!) = ((sum_(i = 1)^k n_i)!)/(product_(i = 1)^k n_i !)$


$ underbrace(a a dots a, n_1 ! \ <---->) , space underbrace(b dots b, n_2 ! \ <---->), dots,  underbrace(x dots x, n_k ! \ <---->)  dot n! $
// TODO: там в конце не просто n! а n!/что-то. в 37 строке
$ n_1 ! n_2 ! ... n_k $

/ Сочетание без повторений: комбинации из $k$ различных элементов, которые отличаются друг от друга только составом элементов

$ C^k_n = (n!)/(k!(n - k)!) $

В каждом сочетании делаем перестановки из $k$ различных элементов. Сколько у нас таких комбинаций получится? Очевидно $k! C^k_n$ и мы получим размещение, то есть $A^k_n = k! C^k_n => C^k_n = A_n^k / k! = n! / (k! (n - k)!)$.

Сочетания часто называют биноминальными коэффеициентами, связывая их с биномом Ньютона. Вспомним:

$ (a + b)^n = limits(sum)_(k = 0)^n C^k_n a^k b^(n - k) $

Свойства сочетаний:

1. $C^k_n = overline(P)(k, n -k)$
2. $C^k_n = C^(n - k)_n$
3. $C^k_n = C^(k - 1)_(n - 1) + C^k_(n - 1)$ --- основное свойство, понадобится для док-ва теоремы на рекурентные соотношения
Доказательство: $C^(k -1)_(n - 1) + C^(k)_(n - 1) = ((n - 1)!)/((k - 1)! (n - k)!) + ((n-1)!)/(k!(n-k-1)!) = (k(n-1)!)/(k!(n-1)!) + ((n-k)(n-1)!)/(k!(n-k)!)$

4. $C^0_n + C^1_n + ... + C^n_n = 2^n$
5. $C^0_n - C^1_n + C^2_n - ... + (-1)^k C^k_n + ... + (-1)^n C^n_n = 0$ 
// TODO: финал доказательства 3 свойства = ПОТРАЧЕНО (последнее равно не успели)
// Надо потом уточнить (4 или 5 свойств)
// там 4, а 5 --- это моя шиза
// ок)
// пиздец мы конченые

// NOTE:
// прочитает эти комменты кто-то из первашей, а тут чел со своей шизой общается

/ Сочетание с повторениями: из $n$ типов по $k$ элементов в любом соотношении называются все такие комбинации из $k$ элементов исходных $n$ типов, которые отличаются друг от друга составом элементов.

$ overline(C)^k_n = C^k_(n + k - 1) = overline(P)(k, n -1) $

Для каждого сочетания запишем сначала количество единиц, равное количеству элементов первого типа

$underbrace(1 space 1 ... 1, #par[кол-во \ э-в \ 1 типа]) | underbrace(1 space 1... 1, #par[2 типа]) | dots | underbrace(1 space 1 ... 1, #par[$n$-й тип])$

В качестве примера возьмём из двух типов три элемента:

$ overline(C)^3_2 $

#table(
	columns: 3,
	table.header([Тип 1], [Тип 2], []),
    [0], [1], [bbb],
    [1],[2], [abb],
	[2], [1], [aab], // o kurwa
	[3], [0], [aaa]
)

$ overline(P)(k, n - 1) = ((n + k - 1)!)/(k! (n -1)!) = C^("что-то")_(n + k -1 "не уверен")$

Многие комбинаторные задачи сводятся к разложению предметов по ящикам. Их разнообразие не такое уж и больше, поэтому такие комбинаторные схемы обычно объединяются в небольшой раздел под названием *комбинаторика разложений*. // TODO: уточнить название комбинаторики

$ A eq.not emptyset, space A_1, A_2, dots, A_n subset.eq A $

/ Мощность:
$ A \\ limits(union)_(i = 1)^n A_i = |A| - limits(sum)_(i = 1)^n |A_i| + limits(sum_(1 <= i_1 < i_2 <= n))_(C^2_k) |A_i_1 sect A_i_2| - limits(sum_(1 <= i_1 < i_2 < i_3 <= n))_(C^3_k) |A_i_1 sect A_i_2 sect A_i_3| + ... \ + (-1)^k limits(sum_(1 <= i_1 < i_2 < i_k <= n))_(1) |A_i_1 sect A_i_2 sect ... sect A-i_k + ... + limits((1)^n)_0 A_1 sect ... sect A_n $

*Доказательство:*

Доказательств этой формулы много, можно и математической индукцией, Сагаева рекомендует вариант из книжки Евлонского. /* Еблонского? */
// Мысли читаешь)))

Возьмём произвольный элемент $A$ и посчитаем, сколько раз он принимает участие в подсчёте мощностей в вышеприведённой формуле. Возникает два случая:

$ a in A $

+ $ a in union.big A_i $
  $ a in k " подмножеств" $ 
+ $ a in.not union.big A_i $

// FIX: #image("./imgs/001.png")

*Пример:*

$ X = { a_i }_(i = 1)^n $
$ Y = { b_i }_(i = 1)^n $

// FIX: #image("imgs/002.png")

Воспользуемся формулой включение/исключения


$ A = { f : X -> Y } $
$ A_i = { f: X -> Y | b_i in.not E_f } $
$ A_1, space A_2, dots, space A_n $
$ |A| = n^m $
$ |A_i| = (n - i)^m $ // TODO: мб здесь (n - 1), надо проверить
$ |A_i sect A_j| = (n - 2)^m $
$ |A_i_1 sect A_i_2 sect dots sect A_i_k| = (n-k)^m $
$ |A \\ limits(union)^n_i A_i | = n^m - n dot (n - 1)^m + C^2_n dot (n - 2)^m - ... + (-1)^(n -1) C^(n - 1)_n dot 1 $

// FIX: #image("imgs/003.png")

// 30 см к югу от головы Сагаевой



















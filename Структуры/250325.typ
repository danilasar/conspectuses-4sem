== Класс NP
Сегодня мы поговорим о задачах класс NP. Они относятся к классу сложных и их нельзя отнести ни к полиномиальным, ни к экспоненциальным. Дело в том, что пока не найден способ их решения за полиномиальное время, но мы можем проверить правильность готового ответа за полиномиальное время. Получается, что недетерменированная машина Тьюринга может решить задачу за полиномиальное время, а детерменированная машина Тьюринга такого алгоритма пока не знает.

Проверить за полиномиальное время можно, если у нас будет существовать "оракул", предлагающий решения.

- Задачи, которые нельзя отнести ни к классу $P$, ни к классу $E$
- Задачи, которые недетерменированная машина Тьюринага может решить за полиномиальное время, тогда как для детерменированной машины Тьюринга полиномиальный алгоритм неизвестен.
- Для этих задач до сих пор не разрабботан эффективный (т. е. полиномиальный) алгоритм, но и не доказано, что таких алгоритмов не существует.
- К классу $N P$ относятся все задачи, решение которых можно _проверить_ за полиномиальное время. Оракул предлагает решения, которые после проверки верификатором за полиномиальное время приобретают "юридическую" силу
*Пример*:
Дано *n* чисел $a_1, dots, a_n$ и число $V$.

Задача: найти вектор (массив) $X = (x_1, dots, x_n), space x_i in {0, 1}$ такой, что $sum a_i x_i = V$. 

То есть может ли быть представлено число $V$ в виде суммы каких-либо элементов массива $A$.

Если какой-то аллгоритм выдаёт результат --- массив $X$, то проверка правильности этого результата может быть выполнена с полиномиальной сложностью: проверка $sum a_i x_i = V$ требует не более $Theta(N)$ операций.

== Проблема равенства классов $P$ и $N P$

Поскольку детерминированная машина Тьюринга может рассматриваться как специальный случай недетерминированной машины Тьюринга, в которой отсутствует стадия угадывания, а стадия проверки совпадает с ДМТ, класс $N P$ включает в себя класс $P$, а также некоторые проблемы, для решения которых известны лишь алгоритмы, экспоненциально зависящие от размера входа (то есть неэффективные для больших входов).

*Вопрос о равенстве этих двух классов считается одной из самых сложных открытых проблем в области теоретической информатики.*


На сегодня отсутствуют теоретические доказательства как совпадения этих классов ($P = N P$), так и их несовпадения.

Предположение состоит в том, что класс $P$ является собственным подмножеством класса $N P$, то есть $N P \ P$ не пусто.

#image("imgs/004.png")

== Класс $N P C$ ($N P$-полные задачи)

Определение класса $N P C$ ($N P$-complete) или класса $N P$-полных задач требует выполнения следующих условий: по-первых, задача должна принадлежать классу $N P$, и, во-вторых, к ней полиномиально должны сводиться все задачи из класса $N P$.



== Полингомиальная сводимость
=== Сведение по Карпу// Поликарпу
Любой язык $L_1$ называется *сводимым по Карпу* к языку $I_0$, если существует функция $F: Sigma^\* <-> Sigma^\*$, вычисляемая за полиномилаьное время, где $F(x)$ принадлежит $L_2$ в том случае, если принадлежит к $L_1$.

Рассмотрим два языка $L_1$  и $L_2$ над алфавитами $Sigma, Gamma$. *Свеение $I_1 -> I_2$ по Карпу* --- это функция $f: Sigma^\* <-> Gamma^\*$, вычислимая за полиномиальное время такая, что $forall x (x in L_1 <=> f(x) in L_2)$. Таким образом, неформально язык $L_1$ не сложнее языка $L_2$.

Если такая функция $f$ существует, говорят, что $L_1$ *сводима по Карпу* к $L_2$ и пишут

$ L_1 <=_K L_2 $

сведение по Карпу является частным случаем сведения по Карпу.

=== Сведение по Куку
 В теории сложности вычислений сведение задачи $R_1$ к $R_2$ --- это полиномиальный по времени алгоритм (другимим словами, машина тьюрига с полиномиальным временм работы), решающий задачу $R_1$ при условии, что функци находщая решение задачи $R_2$ ему дана в качесте оракула, то есть обращение к ней занимает всего один шаг

Если твой алгоритм существует, говорят, что $R_1$ сводимые по Куку к $R_2$ и пишут

$ R_1 lt.eq_C R_2 $

Неформально в этом случае говорят, что $R_2$ как минимум так же сложна как $R_1$

Если задача $R_1$ сводится по Куку к задаче $R_2$ // TODO: бляяяя дописать два предложения



// HACK:
// Урок в кавказской школе. Учитель вызвал ученика и попросил начертить равнобедренный треугольник. Мальчик начертил. Учитель:
// - А теперь докажи, что он равнобедренный.
// - Мамой клянусь, равнобедренный!
// -- прикинь если нет)))

Для класса $N P C$ доказана следующая *теорема*: если существует задача, принадлежащая ему, для которой существует полиномиальный алгоритм решения, то класс $P$ совпадает с классом $N P$, то есть $P = N P$.

В настоящее время доказано сущестовавние сотен $N P$-полных задач, но ни для одной из них не удалось найт полиномиального алгоритма решения. В настоящее время исследвоатели предполагают следующее соотношение классов:

#image("imgs/006.png")

== Примеры $N P$-полных задач
// у меня на KDE стоит два метода ввода, контролирующих раскладки
// один из них предустановлен в кедах и был всегда, я им и пользуюсь
// второй взялся хуй пойми откуда, перехватывает на себя контроль раскладками и максимально выёбывается, отключая попутно старый метод ввода
// вроде как после одного из обновлений арча этот пидорас залез
// я его боюсь удалять

// пиздец
К этому классу относятся следующие задачи:
- задача о выполнимости: существует ли для данной булевской формулы, находящейся в КНФ, такое распределение истинностных значений, что она имеет значение истина?
- задача комимвояжера (Коммивояжер хочет объехать все города, побывав в каждом ровно по одному разу, и вернуться в город из которого начато путешествие. Известно, что переезд из города $i$ в город $j$ стоит $c (i, j)$ рублей. Требуется найти путь минимальной стоимости);
- решение систем уравнений с целыми переменными;
- составление рассписаний, учитывающих определенные условия;
- Размещение обслуживающих центров (телефон, телевидение, срочные службы) для максимального числа клиентов при минимальном числе центров;
- оптимальная загрузка ёмкости (рюкзак, поезд, корабль, самолёт) при наименьшей стоимости 
- Оптимальный раскрой (бумага, картон стальной прокат, отливки), оптимизация маршрутов в воздушном пространстве, инвестиций, станочного парка;

// HACK: Разговаривают два солдатика.
// - Слушай, давай над лейтенантом приколемся.
// - Ага, над деканом уже прикололись…
// -- ахахахахаахаххаха

== Пути решения $N P$-полных задач
1. Поиск приближённого решения (например, использвоание жадных алгоритмов для решения задач о коммивояжёре, о рюкзаке);
2. Организация "разумной" стратегии перебора (например, метод ветвей и границ);
3. Сведение $N P$-полных задач друг ко другу (например, сведение задачи коммивояжёра к задаче линейного программирования);
4. Выделение из общей $N P$-полной задачи эффективно разрешимых частных случаев

// HACK: москвичей нигде не любят, особенно в Москве...
// -- ахахахахаахаххаха

== Когда временными оценками можно пренебречь
- Если создаваемая программа будет использована несколько раз, тогда стоимость написания и отладки программы будет доминировать в общей стоимости программы
- Если программа будет работать только с "малыми" входными данными, то степень роста времени выполнения будет иметь меньшее значение, чем константа, присутствующая в формуле
- Эффективные, но сложные алгоритмы могут быть нежелательны, если готовые программы будут поддерживать лица, не имеющие достаточной квалификации для того, чтобы в них разобраться
- Известно несколько примеров, когда эффективные алгоритмы требуют таких больших объемов машинной памяти, что этот фактор сводит на нет их преимущество.
- В численных алгоритмах точность и устойчивость не менее важны, чем их временная эффективность.







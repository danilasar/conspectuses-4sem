= Лекция 2. 18 февраля 2025.

Останавливается на машине Поста мы не будем. Если у кого-то что-то неправильно, это его проблемы. 

Сегодня мы разберём машину Тьюринга и рассмотрим алгоритм как последовательность смен конфигураций машины Тьюринга.

== Машина Тьюринга

Тьюринг-полный язык --- это язык, эквивалентный редстоуну в майнкрафте.

/ Машина Тьюринга: --- Бесконечная линия в обе стороны. 

=== Формальное определение машины Тьюринга

В зависимости от считываемого символа и собственного состояния, управляющий модуль может производить следующие операции:
- записывать символ алфвита в ячейку (в том числе и пустой), заменяя находившийся в ней (в том числе и пустой)
- Сдвинуть указатель на одну ячейку влево, вправо или остаться на месте
- Поменять свое внутреннее состояние;

- Конечное множество состояний $Q = {q_1, dots, q_n}$, в которых может находиться машина Тьюринга, называется *внутренним алфавитом*
- Конечное множествосимволов ленты $A = {a_1, dots, a_n)$, называемое *внешним алфавитом*
- Функция $delta$ (функция переходов или программа), которая задаёт отображение пары из декартова произведения $Q x A$ (машина находится в состоянии $P$ и обозревает символ $a_k$) в тройку декартова произведения $Q x A x (I, R, E)$ (машина переходит в состояние $q_k$, заменяетсимвол $a_k$ на символ $a_i$ и передвигается влево, вправо на один символл ленты или остаётся на месте) --- $Q x A -> Q x A x (L, R, E): q_i a_k limits(->)^B q_j a-m d, d in (L, R, E)$. Предполагается, что для каждой пары $q_i a_k$ $i = overline(1\, dots\, n) j k = overline(0\, dots\. t)$ имеется точно одна команда. Множество  этих команд называется программой и в программе имеется $n(t+1)$ комнад;
- Один символ $e in A$  (пустой);
- Подмново $sum in A$ определяется как подмножество входных символов ленты, причем $e in (A - sum)$;
- одно из состояний $- q_1 in Q$  является начальным состоянием машины, а $q_1 in Q$ заключительным.


=== Способы задания МТ

1. Список команд
$A = {a_0 = lambda, a_1 = 1}$ и $Q = {q_0, q_1, q_2}$
- $q_1 lambda -> q_2 1 E$
- $q_1 1 -> q_1 1 R$
- $q_2 1 -> q_2 1 L$
- $q_2 lambda -> q_0 lambda R$
2. Таблица переходов
#table(columns: 3,
	[], $a_0$, $a_q$,
	$q_1$, $q_2 a_1 E$, $q_1 a_1 R$,
	$q_2$, $q_0 a_0 R$, $q_2 a_2 L$,
	$q_0$, $dots$, $dots$
)
3. Граф переходов

// #image("imgs/001.png")

Стрелки на графе показывают переходы между состояниями, вершины суть состояния машины и, наконец, символом | разделяются входные и выходные данные функции переходов.

=== Конфигурация машины Тьюоринга

Работа машины Тьюринга заключается в изменении конфигурации.

/ Конфигурация: --- представляется собой совокупность состояния ленты и в положении указателя на лете. 

Конфигурацию можно предстваить в виде магинного слова в  алфавите:

$A union Q$ вида $alpha_1 q_i alpha_2$

Эта кофигурация соответствует следующей ситуации:

// #image("imgs/002.png")

Машина обозревает первый символ слова $a_2$ ...

Конфигруацию в момет времени $t$ обозначчим $K_i$ Машина реализует процесс изменения кофигурации в следующем смысле. Если $K_0 = q_1 alpha$ и $alpha = a_i alpha'$, $a_i in A$, то в программе машины имеется точно одна команда вида $q_1 a_i --> q_k a_i d$. Тогда следующая кофигурация $K_1$ определяется так:

- $K_1 = q_k a_1 alpha'$, если $d = E$
- $K_1 = a_1 q_k alpha'$, если $d = R$
- $K_1 = q_k a_0 _(a 1) alpha'$, еслли $d = L$

Это обстоятельство записывается в виде $K_0 -> K_1$. Если теперь конфигурация $K_1$ не является заключительной, тто в соответсвтии с системой команд, аналогично предыдущему, определима однозначно следующая конфмигруация $K_2$, т. е. $K_1 -> K_2$. Таким образом начальная конфигурация $K_0$ описывает последовательност конфигураций

$ K_1 -> K_2 -> dots -> K_i -> K_(i +  1) -> dots $

Если последовательность конечна, т. е. обрывается в заключительной конфигуарции, то говорят, что машина _применима_ к когфигурации $K_0$, в противном случае _неприменима_ к $K_0$


Эта последовательность называется протоколом.

=== Приведение конфигураации к стандартному виду

Стандартная начальная конфигурация имеет вид $q_1 alpha$. Стандрартная заключительная $q_0 alpha$.

Можно привести заключительную конфигурацию к стандартному виду используя следующий прием:

Добавим к МТ два новых состояния $q' q''$ и команды

- $q_0 a_i -> q' a_I L, i = overline(0\, m)$
- $q' a_0 -> q'' a_o R$

При этом в состояние $q''$ объявим заключительным. Полученная машина Тьюринга' эквивалентна машине Тьюринга в следующем смысле:
- Обе машины применимы к одним и тем же начальным конфигурациям.
- Результаты применения обеих машин совпадают
- Заключительные конфигурации у машины T' находятся в стандартной форме.

=== Определение вычислимости по Тьюрингу

ВБудем рассматривать функции $f$ следующего типа: $f: A' -> A'$, где $A'$ --- множество всех слов конечной длины в алфавите A.

Говорят, что МТ вычисляет функцию $f_(M T)$, если для любого $alpha in A'$ выполнено:

$
f_"МТ" (alpha) = cases(
	beta\, "если" "МТ"(a) = beta, "т. е." (K_0 = q_2 a) and (K_1 = q_0 beta),
	"не определена, если МТ(a) не останавливается"
)
$

_Функция $f$ называется вычислимой по Тьюрингу, если существует МТ которая ее правильно вычисляет._

Для каких-то слов у нас машина может найти ответ, а для некоторых (если она неприменима для них) она будет работать бесконечною

==== Для нескольких переменных

Рассмотрим функцию $f (x_1, ..., x_n)$ от $n$ переменных, аргументы которой и ее значения принадлежат множеству $N_0 = {0, 1, 2,...}$

Будем считать, что алфавит $A$ машины Тьюринга содержит 1.

Будем представлять произвольные числа $x in N_0$ в виде слов $|^(x + 1) = |limits("{")_(x + 1) 1 dots 1$, чтобы запись нуля была непустой. Будем говорить, что машина правильно вычисляет функцию $f(x_1, dots, x_n)$, если 

МТ Правильно вычисляет функцию $f(x_1,..., x_n)$, если  конфигурацию $|q_1| ..._(x_1+1)| \* |_(x_1+1)$ "здесь передсносом вниз должно быть\{"

если значение f(x_1, dots, x_n) определено и МТ неприменима, если значение f(x_1, dots, x_n) неопределено. Здесь \* ---- символ-разделитель из A.

=== Пример 1

Пусть $A= {a_0 = lambda, a_1 = 1}$ и ${Q = q_0, q_1, 1_2}$

Программа $"МТ"_1$:
- $q_1 lambda -> q_2 1 E$
- $q_1 1 -> q_1 1 R$
- $q_2 1 -> q_2  1 L$
- $q_2 lambda -> q_0 lambda R$

Пусть $K_0 = q_1 1^(x + 1)$. Тогда $"МТ"_1$ порождает следующую последовательность конфигураций:

$q_1 1^(x+1) -> 1 q_1 1^x -> dots -> 1^(x+1) q_1 lambda -> 1^(x+1) q_2 1 -> dots -> q_2 1^(x+2) -> q_2 lambda 1^(x+ 2) ->  q_0 1 ^(x + 2)$

Таким образомб $М Т_1$ правильно вычисляет функцию $f(x) = x + 1$, $x in N_0$

=== Пример 2

Пусть $A = {lambda, 1}$, $Q = {q_0, q_1, q_2}$

Программа $"МТ"_2$:
- $q_1 lambda -> q_1 lambda R$
- $q_1 1 -> q_2 lambda R$
- $q_2 1 -> q_2 lambda R$
- $q_2 lambda -> q_0 1 E$


Пусть $K_0 = q_1 1^(x + 1)$ Тогда

=== Пример 3. Вычисление суммы

Пусть $A = {lambda, 1, *}, Q = {q_0, q_1,q_2, q_3}$

Программа $М Т_3$
- $q_1 1 -> q_2 lambda R$
- $q_2 1 -> q_2 1 R$
- $q_2 * -> q_2 1 R$
- $q+2 lambda -> q_3 lambda L$
- $q_3 1 -> q_4 lambda L$
- $q_4 lambda -> q_0 lambda R$
- $q_4 1 -> q_4 1 L$
(остальные команды не важны для вычисления).

Пусть $K_0 = q_1 1^(x+1) * 1^(x+1)$. Тогда мешина $M T_3$ попрождает следующую последовательность кофигурации:

$q_1 1^(x+ 1) * 1^(y + 1) -> q_2 1^x * 1^(y + 1) -> dots -> 1^x q_2 * 1^(y + 1) -> 1^(x + 1) q_2 1^(y + 1) -> 1^(x + y + 2) q_2 lambda -> 1^(x + y + 1) q_3 1 -> 1^(x + y) q_4 1 -> dots -> q_4 lambda 1^(x + y + 1) -> q_0 1^(x + y + 1)$

Т.е. машина $T_3$ правильно вычисляет функцию $f(x) = x + y$ $x, y in N_0$

== Операции над машинами Тьюринга

1. Псоледовательная композиция МТ.

Поусть даны две машины Тьюринга $T_1$ и $T_2$, которые вычисляют соответствующие функции $f_1(a)$ и $f_2 (a)$ в одном и том же алфавите.

Тогда существует машина Тьюринга $T$, которая вычисляет функцию $f(a) = f_2(f_1(a))$. При этом для любого слова $a$ машина определена в том и только в том случае, когда $f_1 (alpha)$ определена и $f_2(f_1(alpha))$

Программа машины Т строится так: Состояния машины $T_2$ переобозначаем так, чтобы они отличалисть от состояний машины $T_1$ . Начальное...

2. Операция ветвления (условный оператор)

Пусть даны две машины Тьюринга $T_1$ и $T_2$ , которые вычисляют соответствующие функции $f_1 (alpha)$ и $f_2 (alpha)$ в одном и том же алфавите.

Тогда существует машина Тьюрнга Т, которая вычисляет функцию $f (alpha)$ определенную следующим образом

$
    f(alpha) = cases(
        f_1 (alpha)\, "если" P(alpha),
        f_2 (alpha)\, "иначе"
    )
$



о есть нужно уметь вычислять предикат $P(a)$, а значит построить машину Тьюринга $T_p$, вычисляющую предикат. Вычислить можно двумя способами:

 1. Заменить на ленте $P(a)$ на 0 или 1, но это очень часто сделать нельзя, т. к.. необхоимо сохранить входное слово $a$. Поэтому существует второй ввариант.
 2. Вычисление с восстановлением, дающее в заключительной стандартной конфигурации $q_0^p epsilon * a$.

$ P(a) = epsilon * a, "где" epsilon in [0,1) $

Тогда машина Тьюринга ...


Существуют машины Т вытекает из следующих конструкций. Строится МТ $T_p$ вычисляющая предикат с восстановлением.

Пусть $q_1^1$ и $q_1^2 $ --- начальные состояния машин $T_1$ и $T_2$ соответственно. Считаем, что множества внутренних состояний машин не пересекаются. Строим промежуточную машину $T_3$ с начальным состоянием $q_1^3$ и системой команд

$sum_1 union sum_2 union {\
    q_1 0 -> q^1_1 lambda R\
    q^1_1 * -> q^1_1 lambda R\
    q_1 1 -> q^2_1 lambda R\
    q^2_1 * -> lambda R\
}
$
где $Sigma_i$ --- команды машины $T_i$.

Теперь заключительные состояния $q_1^1$ и $q_1^2$ машин $T_1$ и $T_2$ объединим, а полученное состояние $q_0$ считаем заключительным для $T$.

3. Реализация цикла.


Пусть имеем функции $f_1$ и $f_2$ и екоторый предикат $P$ на словах (его значения обозначим 0, 1). Для произвольного слоа $a$ проверяется, верно ли $P(alpha) = 1$. Если да, то выдаётся $f_1 (alpha)$, иначе $a' = f_2(alpha)$ и рекурсивно повторяем. Существует машина Тьюринга $T$, реализующая даннную прцедуру. Пуусть существуют машины Тьюринга для вычисления функций $f_1, f_2$ и предиката $P$. Обозначим на $T_1$


$T_2, T_p$ Соответственно, машина Т строится в соответствии со схемой;

Заключительные состояния $q^1_0$ и $q^2_0$ машин $T_1$ и $T_2$ не объединяются, а счтаются различными. Состояние $q^1_0$ объявляется заключительным для $T_1$, а $q^2_0$ отождествляется с начальным...

=== Существование универсальной машины Тьюринга

*Теорема: построение универсальной машины Тьюринга*

Пусть $T_1 (alpha) dot sum_1$, $T_2 (alpha) dot sum_2, ..., T_n(alpha) dot sum_n ...$ -- машины тьюринга и их системы команд, можно ли построить такую машину $T_u (alpha, sum_(T_u)) = T_(alpha)$, т.е . на ленте записываем не только аргумент машины $T_u$, но и систему команд этой машины.


Доказательство этой теоремы конструкктивное.

$sum_T_i$ --- это не просто система команд машины $T_i$, а это некоторый её код в алфавите машины $T_u$.

Универсальную ашину можно рассматривать как вычислительную машину общего назначения, которая достаточно мощна для того, чтобы моделировать любую вычислительную машину, включая саму себя.

/ Тезис Тьюринга: если функция вычислима, то существует машина Тьюринга, которая её вычисляет.

= Рекурсивные функции

Эта модель рассматривает алгоритм как способформиования одних вычислимых функций из других, т. е. оним функции конструктивно определбятс на других.

*Покаяние простейших функций*


Числовые фукнции, значение которыъ можно установить посредством некоторого алгоритма, называются вычислимыми функциями.
// надо будет быстро собраться на тервер

Для тооого, чтобы описать клас функций с помощью рекурсивных определений, рассмотрим набор простейших функций:


+ $Z(x_1, x_2, ..., x_n) = 0$ --- нуль-функция, которая опрделена для всех неотрицательных значений аргумента;
+ $s(x) = x + 1$ --- функци непосредственного следования, также опрелённая для всех целых нотрицательных начений своего аргуумента
+ $I_m'' (x_1, dots, x_m, dots, x_n) = x_m$ ---- функция выбора (тождества),повторяющая вычисления своих аргументов.

Используя простейшие функции в качестве исходных функций можно с помощью небольшого числа общих конструктивных приемов строить сложные арифметические функции. В теории рекурсивных функций особо важное значение имеют три операции: суперпозиции, примитивной рекурсии и минимизации.

*Эти операторы сохраняют вычислимость*

Все элементарные функции --- всюду определённые и алгоритмически вычислимые.








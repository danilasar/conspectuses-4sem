= Лекция 4. 11 матра 2025.

== Алгоритмически неразрешимые задачи

- Любая вычислимая функция может быть вычислена разными алгоритмами (разными программами для выбранного универсального исполнителя) и может быть вычислена с помощью лбого универсального исполнителя: машин Тьюринга и Поста, нормальных алгоритмов Маркова и др., #text(fill: rgb("#ff0000"), "но существуют и алгоритмически невычислимые функции для которых не существует алгоритма решения").
- Однако алгоритмическая неразрешимость задачи ого или иного класса вовсе не ощначает невозможность решения любой *конкретной* задачи того или иного класса. Речь идёт о невозможности решения всех задач данного класса одним и тем же примером.
- Формализация понятия алгоритма позволила исследовать существование задач, для которых нет алгоритмических решений.





=== Методы доказательтства алгоритмической неразрешимости

- *Прямой метод* использует диагональный метод Кантора. Заключается он в следующем: из предполоожения о разрешимости данной проблемы в ходе рассуждений приходят к противоречию.

- *Косвенный метод* состоит в следующем: показывается, что разрешимость исследуемой проблемы влечёт разрешимость проблемы, о которой уже известно, что она неразрешима. Метод сведения часто бывает более удобным, чем прямой метод. Применяя метод сведения, обычно ссылаются на искусственные задачи, которые не представляют самостоятельного интереса, но для которых легко непосредственно доказать их неразрешимость


=== Диагональный метод Кантора

Теорема Кантора о несчетности множества действительных чисел: множество натуральных числе и множество действительных чисел сегмента $[0, 1]$ имеют разную можность. Доказательство диагональным методом.

Теорема Кантора о несчётносте множества действительных... // TODO:

*Доказательство (от противного)*.Действительные числа сегмента $[0, 1]$ будем представлять бесконечной десятичной дробью и предполагаем изначально, что у нас сущесвтвует взаимно однозначное отображение между множеством действительных и натуральных чисел, значит мы можем все действительные числа пронумеровать.// TODO:
 
// HACK:
// Я думаю, нет смысла писать это доказательство, ведь оно было в 1 семестре матана
// - Именно, я согласен. Это буквально самая первая теорема с доказательством

Приходим к следствию:

/ Теорема: Множество арифметических функций $n$--переменных несчётно.

* Докозательство * (с помощью диагонального метода):

Для доказательства несчётности множества достаточно доказать несчётность какого-нибудь подможества . Рассмотрим функции одной переменной вида $F_i(x)$. Пусть функций одной переменной счётное множество, т.е. их можно перенумеровать. $F_0(x), F_1(x), F_2(x), dots$

Построим новую функцию $G(x) = F_x (x) + 1$. Это так называемая диагональная функция $G(0) = F_0 (0) + 1, space G(1) = F_1 (1) + 1, space G(2) = F_2 (2) + 1$ и тд. $G$-отлична от всех перечисленных функций, т.к. от каждой из функций она отличается хотя бы в одной точке. От функции $F_0 (x)$ отличается в точке $x = 0$ от функции $F_1 (x)$ в точке $x = 1$ и тд. Однако по построению $G(x)$ принадлежит множеству арифметических функций одной переменной, значит должна быть в списке, т.е. совпадать с одной из перечисленных функций.

Получили противоречие, следовательно исходное предположение неверно, и функций одной переменной несчётное множество. А значит и всех функций $n$ переменных --- тоже несчётное множество.


/ Теорема: Вычислимых функций счётное множество. (Множество машин Тьюринга счётно)

*Доказательство*. // - Как же лень писать(
Программу всякой МТ можно интерпретировать, как слово в некотором конечном алфавите. Это можно сделать, например, так:

Пусть $A = {0, 1, 2, dots, 9, a, q, R, L, S, ->, |}$ --- алфавит. Он сожержит 17 символов. Рассмотрим программу МТ, например, такую:

$ q_1 a_1 -> q_k a_l R $
$ q_1 a_2 -> q_j a_i L $ // TODO: дописать, не уверен насчёт это строчки
$ dots $
$ q_m a_n -> q_r a_t S $

Запишем теперь все команды в одну строчку, разделяя их символом $|$ и заменяя нижние индексы на равные м чсла, но расположенные уже на уровне основного текста:

$ q 1 a 1 --> q k a l R | q 1 a 2 --> q i a j L |dots| q m  a n -> q r a t S $

Мы получили слово в алфавите А. По этому слову программа машины ТЬюринга восстанавливается однозначно. Но очевидно, что не всякое слово из $A\*$ является программой некоторой машины Тьюринга

// пишу ласт абзац
Таким образом, каждая машина Тьюринга вполне определяется некоторым конечным словом в конечном стандартном алфавите. Поскольку множество всех конечных слов в конечном алфавите счётно, то и всех мыслимых машин Тьюринга (отличающихся друг от друга по существу своей работы) имеется не более чем счётное множество.

== Оценка мощности множеств

// Здесь была картинка :)

// FIX: #image("imgs/003.png")

== Проблемы самоприменимости и остановки

Эти задачи часто используют для доказательства неразрешимости других проблем путём сведения к ним.

=== Нумерация алгоритмов

Существует вычислимая функция, которая по номеру машины Тьюринга (алгоритма) восстанавливает её программу (описание алгоритма) $phi: NN -> A$. Такая функция называется нумерацией алгоритмов. Это позволяет отождествлять алгоритм с его номером. Если $phi(n) = A$, то число $n$ называется номером алгоритма $A$ Из взаимной  однозначности отображения $phi$ следует существование обратной функции $phi^(-1)$, восстанавливающей по описанию алгоритма $A_n$  его номер в этой нумерации $phi^(-1) (A_n) = n$

Существование нумерации позволяет работать с алгоритмами как с числами. Это особенно удобно при исследовании алгоритмов над алгоритмами.

*Проблема останова.*

Не существует алгоритма (МТ), позволяющей по описанию этого алгоритма и исходных данным определить, остановиться ли алгоритм на этих данных, или будет работать бесконечно.

Иными словами, мы не можем построить универсальный интерпретатор для алгоритма.

/ Самоприменимость: (частный случай проблемы останова) в теориии алгоритмов --- свойство алгоритма успешно завершатться на данных, представляющих собой формальную запись этого же алгоритма.

*Пример самоприменимости алгоритма*: тождественные преобразования строк в алфавите $A$.

/ Теорема: Не существует МТ $T_0$, которая решает проблему самоприменимости.


Возьмем в качестве внешнего алфавита для машин Тьюринга $A = {0, 1}$. Будем говорить, что $M T T_0$ решает *проблему самоприменимости*, если для любой машины $T$ конфигурацию $q_1$ Код $(T)$ она переводит в конфигурацю $q_0 1$, если $T$ самоприменима, и в конфигурацию $q_0 0$, если $T$ --- несамоприменима.

*Доказательство*. Допустим, что существует МТ $T_0$, решающая проблему самоприменимости. Построим МТ $T_1$, в которой вместо состояния $q_0$ введём новое заключительное состояние $q_r$ и добавим к программе МТ $T_0$ новые комманды:

$ q_0 1 -> q_0 1 E, #[(зацикливание)] $
$ q_0 -> q_r 0 E (*) $


То есть у нас есть свойство $T_0$, которое позволяет определить состояние для любой машины Тьюринга. Мы на вход $q_1$ ставим код машины Тьюринга $T$ и на выход $q_0$ мы должны получить либо 0, либо 1.

Машина $T_1$ построена по машине $T_0$ вполне конструктивными средствами и применима к кодам насамоприменимых машин и не применима к кодам самоприменимых машин.

*Существование такой машины приводит к противоречию*, потому что $T_1$ не может быть ни самоприменимой, ни несамоприменимой.

Действительно, если $T_1$ --- самоприменима, то $q_1$ Код $(T_1)$ переходит в $q_0 1$ и согласно $(*)$ $q_0 1$ в $q_0 1 E$ и $T_1$ никогда не остановится, т.е. по построению она не применма к коду самоприменимых машин.
а

Если $T_1$ --- не самоприменима, то $q_1$ Код ($T_1$) переходит в $q_0 0$ и согласно $(*)$ $q_0 0$ в $q_r 0$ и машина $T_1$ остановится, т.е. по построению она применима к собственной записи, т.к. она применима к любой записи несамоприменимой машины, а это означает, что $T_1$ самомоприменима.

Получили противоречие, то есть допущение о существовании МТ, решающей проболему самоприменимости, неверно.

В силу тезиса Тьюринга невозможность построения МТ означает отсутствие алгоритма решения данной проблемы.


=== Проблема останова MT и доказательство её неразрешимости

- Одна из первых задач, для которой была доказана неразрешимость. 

- Доказательство её неразрешимости проводится с помощью диагоального метода и свойства смоприменимости алгоритма.


- Задачу останова часто используют для доказательства неразрешимост других проблем путем сведения к ней.


/ Теорема: Не существует алгоритма (МТ), позволяющего по описанию произвольного алгоритма и его исходным данным, определить, останавливается ли данный алгоритм на исходных данных или будет работать бесконечно.

*Доказательство*:

Рассмотрим множество всех алгоритмов, полуающих на вход натуралное число, то есть отображения $N -> N^*$, где $N^* = N union "undef"$, где $"undef"$ -- случай, когда алгоритм зацикливается, то есть не заканчивает свою работу.
Эта абстракция допустима, так ка слова в люом конечном алфавите можно однозначно закодировать натуральными числами

Докажем, что не существует универсальной функции, которая определяет остановится ли алгоритм на данном входе ил будет работать бесконечно.

Пусть существует вычислимая функция  $F(a, x)$, принимающая значения на $N*$. Первый аргумент $a$ --- номер описания алгоритма на некотором языке, второй аргумента $x$ --- входные данные для этого алгоритма. $F(a, x)$ по определению есть резултат выполненя алгоритма а на вохдных данных $x$.

Вычислимая функция $F(a, x)$ двух натуральных аргументов как бы перечисляет ВСЕ вычислимые функции с одним натуральным аргументом. (Предполагается, что натуральными числами $a$ шифруется множество всех алгоритмов). Рассмотрм эту функцию с точки зрения самоприменимости т.е. $F(a, a)$, где входом для алгоритма с номером $a$ будет формальная запись этого же алгоритма, и построим функцию $h(a) = F(a, a) + 1$.

Функция $h(a)$ --- вычислимая, т.к. она использует результат вычислимой функции $F$ и после прибавляет к нему единицу. Пусть функция $h(a)$ имеет номер $y$, то есть, $F(y, a) = h(a)$. Но по определению $h(a) = F(a, a) + 1$ и при $y = a$ имеем $F(a, a) = h(a)$ и $h(a) = F(a, a) + 1$. Получили противоречие.

Таким образом определение того, остановится или нет программа, является *невычислимой функцией*.


Неразрешимость проблемы останова можно интерпретировать как несуществование общего алгоритма для отлаки


// ЁБАНА В РОТ
// - А нафига мы это пишем ручкаи, если можно CTRL+C, CTRL+V?
// дохуя умный да
// - С кем мне приходится работать...

== Основы анализа сложности алгоритмов
 
=== Критерии оценки эффективности алгоритмов:

/ Процессорное время: (вычислительная сложность)
/ Память: (максимальное количество ячеек задействованных алгоритмом)

*Каждое вычислтелььное устройство имее свои особенности, которые могут влиять на длителььность вычисления при этом алгориитм не становится хуже или лучше!*

=== Пример:
... // TODO:

/* HACK:
 * Два грузина играют в шахматы. 
 * Один делает ход ферзем: - Мат! 
 * Второй двигает навстречу ему короля:
 * - Атэц.
 */
// - Безумно можно быть первым




== Модель абстрактного вычислителя --- машина с прозвольным доступом к памяти

*Модель состоит из памяти и процессора, которыю работают следующим образом*:
- память состоит из ячеек, каждая из которых имеет адрс и может хранить один элемент данных;
- каждое обращение к памяти занимает одну единицу времени, независимо от номера адресуемой ячейки;
- количество памяти достаточно для выполнения любого алгоритма;
- процессор выполняет любую элементарную операцию (основные логические и арифметические операции, чтение из памяти, запись в память, вызов подпрограммы и т.п.) за один временной шаг;
- циклы и подпрограммы не считаются простыми операциями.

*Число  элементарных операций алгоритма на этой одели показывает относительное время выполнения алгоритма*


Неудобно оценивать алгоритм по фактическому элементарных операций на тех или иных входных данных.

*Пример:*

Сложность алгоритма $A = 372 n^ 3 + 15 n^2 + 100$
Сложность алгоритма $B = n^4$

На входе $n = 186$ почти одинаковое количество операций, при $n gt 187$, второй алгоритм выполняет большее количество операций.

_При входах малой длины все алгоритмы можно считать эффективными._

Задача анализа сложности алгоритма состоит в исследовании того, как меняется время работы при увеличении объёма входных данных. Поэтому временная сложность алгоритма определяется числовой функцией, соотносящей время работы алгоритма с размером задачи, т.е. показывающей _*зависимость *_ конкретного лгоритма от размера входных  данных, *что дает возможность сравнить два алгоритма по скорости роста числа операций*

_Именно скорость роста играет ключевую роль, поскольку при небольшом размере входных данных алгоритм $A$ на входе длины $n$ может требовать меньшего количетсва операций, чем алгоритм $B$, но при росте объёма входных данных ситуация может поменяться на противоположную_

*Размер входа определяется для каждого типа задач индивидуально.*

1. В задачах оработки массивов размером входа принято считать количество элементов в массиве;

2. в задачах обработки чисел (длинная арифметика, проверка на простоту и т.д.) более естественно считать размером общее число битов, неообходимое для представления данных в памяти компьютера;

3. в задачах обработки графов разумно за размер входа принять количество вершин графа, а иногда прдставить двумя занчениями: число вершин и число ребер графа.


=== Формальное описание (комплексная оценка алгоритмов)
// - Люблю я тебя *чердечко*
- Конкретная прблема задаётся $N$ словами памяти по $alpha$ битов каждое $N_alpha = N dot alpha$
- Программа, реализующая алгоритм, состоит из $M$ машинных инструкций по $beta$ битов --- $M_beta = M dot beta$
- $S_d$ --- память для хранения промежуточных результатов
- $S_t$ --- память для организации вычислительного процесса

/ Трудоёмкость алгоритма: --- количество элементраных операций, совершаемых алгоритмом для решеия конкретной проблемы, заданной $N + M + S_d + S_T$ словами памяти в данной формальной системе.

/ Функцией трудоёмкости $T_a(N)$: называется отношение, связывающее входные данные алгоритма с количеством элементарных операций.

Комплексный анализ алгоритма может быть выполнен на основе комплексной оценки ресурсов формальной системы, требуемых алгоритмом для решения конкретных проблем. Очевидно, что для различных областей применения веса ресурсов будут различны, что приводит к следующей комплексной оценке алгоритма:

/ Комплесная оценка алгоритма: ($c_i$ --- веса ресурсов):

$ psi_A = c_1 * T_a (N) + c_2 dot N + c_3 * M + c_4 * S_d + c_5 S_d $ // TODO: заменить единицы на нормальные индексы

=== Зависимость трудоемкости от входных данных

Не всегда количество элементарных операций, выполняемых алгоритмом на одном входе длины $N$, совпадает с колиеством операций на другом входе такой же длины.

Пусть $D_A$ --- множество конкретных проблем данной задачи, заданное в формальной системе. Пусть $D in D_A$ --- конкретная // TODO: дописать

// TODO: дописать

Введём следющие обозначения:

1. $T'_alpha (N)$ --- худший случай --- наибольшее количество операций, совершаемых алгоритмом $A$ для решеия конкретных проблем размерностью $N$:

$ T'_alpha (N) = limits(max)_(D in D_N) { T_alpha (D) } #[ --- худший случай на ] D_N $

2. $T_a ^V (N)$--- лучший случай --- наименьшее количество операций, совершаемых алгоритмом $A$ для решения конкретных проблем размерностью $N$:

$ T_a ^V (N) = limits(min)_(D in D_a) {T_a (D)} #[ --- лучший случай на] D_N $


3. $overline(T)_a(N)$ --- средний случай -- среднее количество операций, совершаемых алгоритмом $A$ для решения конкретных проблем размерностью $N$ // TODO: проверить текст в конце

Для нахождения среднего значения, сначала определяются всевозможные СУКИ // TODO:



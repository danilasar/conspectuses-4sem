= Альтератор как фреймворк
Миша Чернигин, разработчик Базальт СПО

Лекция про альтератор, но она будет достаточно специфичная. Сначала мы познакомимся с альтератором в том виде, в котором он используется, потом познакомимся с его архитектурой и напишем приложение на альтераторе.

== Что сегодня будет?

+ Посмотрим, что такое альтератор
+ Изучим его архитектуру
+ Напишем простое приложение

== Что такое альтератор?

/ Альтератор: --- это инсталятор и конфигуратор операционных систем Альт.

Текущая его реализация предполагает возможность написания модулей на Scheme и Qt с бекендом на Bash.

Центр управления системой, он же System management center, визуально очень напоминает панель управлления винды. Тут можно, например, настротить дату и время. Какие-то модули отличаются по уровню проработанности и полезности. Тут можно посмотреть примечания к выпуску, лицензию, провести базовые настройки системы.

== Что не так?

- Scheme и Qt усложняет написание фронетндов 
- Нет возможности писать фронтенды на других языках и технологиях
- Запуск в графике доступен только руту

Минус последнего в том, что не всё, что есть в альтераторе, должно быть недоступно непривелегированному пользователю: например, лицензию.

== Какие целы мы преследуем в новой версии?

- Спецификация интерфейсов бекендов для создания фронтендов
- Обеспечение свободы в выборе технологий для реалищзации фронтендов и бекендов
- Предоставление разработчикам фроеймворка для создания собственных приложений
- Обобщение механизмов локального и удалённого конфигурирования системы

Базальт хочет, чтобы новый альтератор мог работать по сети.

Из коробки идёт старая версия альтератора `alterator-browser`. Новую установить можно с помощью команды
```sh
sudo pat-get install alterator-explorer
```

В новом альтераторе больше функций и он запускается без рута. Миша в новом альтераторе занимается разработкой апплета компонентов.

== Давайте потыкаем новую версию

Как это работает теперь? Раньше альтератор работал через собственную шину, по которой общались фронтенд и бекенд, теперь общение идёт через шину межпроцессорного взаимодействая DBus. В приложениях мы просто взаимодействуем с API, котрое предоставляет DBus.

В системной части альтератора находится менеджер альтератора, написанный на Си, и имеющий модульную архитектуру. Здесь можно дописывать модули.

Как это выглядит на DBus? Давайте посмотрим. Есть много способов, мы воспользуемся утилитой DFeet. Она нам позволяет посмотреть всё, что есть на DBus. Нам интересен сервис `org.altlinux.alterator`, в котором есть немало объектов --- каждый из них здесь представляет какой-то компонент.

Каждый объект DBus предоставляет какой-то набор методов.

Одни приложения предоставляют такие методы, другие их вызывают.

Давайте же опишем свой модуль для альтератора. Наши функции мы описываем маленьким toml файлом:
```toml
type = "Backend"
mmodule = "executor"
name = "example"
intrface = "example1"

[methods.ToggleLed]
execute = "path"
action_id = "ToggleLed"
```

DBus описывает интерфейсы в `xml`:
```xml
<node>
	<intrface name="org.altlinux.alterator.example1">
		<method name="ToggleLed">
			<arg type="i" name="response" direction="out"></arg>
		</method>
	</intrface>
</node>
```

Наш будущий модуль будет выключать светодиод, яркость которого описана в `/sys/class/leds/tpacpi::power/brightness`.

Если рут запишет туда 0, лампочка погаснет. Если 1, то загорится. Другие значения записать не получится.

Давайте вынесем управление лапочкой на волю непривелигеровнных пользователей с помощью альтератора.

```sh
#!/bin/bash -efu

toggle_file = /sys/class/leds/tpacpi::power/brightness

current_status = $(cat "$toggle_file")

if [ "$current_status" = "0" ]; then
	echo 1 > "$toggle_file"
else
	echo 0 > "$toggle_file"
fi
```

Скрипт требует прав администратора. С помощью poolkit мы сможем наделить пользователя правом исполнять что-то на DBus.

```xml
<policyconfig>
	<action id="...">
		<description></description>
		<message></message>
		<defaults>
			<allow_any>yes</allow_any>
			<!-- ещё парочка -->
		</defaults>
	</action>
</policyconfig>
```

Также напишем SPEC файл для пакетирования. Он раскидает интерфейс и сам бекенд в `/usr/share/alterator/backends`.

Соберём пакет с помощью `gear-rpm`. Установим получившиеся пакеты интерфейса и бекенда с помощью `rpm -i`. Теперь среди кучи объектов в `org.altlinux.alterator` на DBus появится наш метод `ToggleLed`.

Осталось написать фронтенд. В данный момент мы создаём расширение для GNOME. Рассмотрим соседний пакет.

metadata.json:
```
{
	"name": "Power Led",
	"description": "Control led of power button",
	"uuid": "...",
	...
}
```

В `extension.js` лежит код на JavaScript, который создаст нам кнопку и повесит на её нажатие вызов сигнала. При обработке сигнала произойдёт вызов на DBus --- вуаля! Остаётся лишь приправить обработкой ошибок.

_Жёстко вспомним, что `org.altlinux.alterator` находится сейчас на системной шине. На сессионной он тоже есть, но в данном кейсе мы его не задействуем. Это ни на что не влияет, права на вызов метода у непривлеегированных пользователей всё равно есть, просто интересный факт._

Поставим в SPEC-файле на уровне системы расширение GNOME, чтобы потом его смогли включить пользователи.

Весь путь, проделанный нами, можно было сделать без альтератора, написав свой сервис на DBus, но альтератор нам серьёзно упростил задачу и это не может не радовать.

Собственно, поэтому альтератор можно теперь рассматривать не просто как центр управления системой, а как полноценный фреймворк для создания приложений.

Теперь наши приложения всё ещё на Qt, но уже не конкретно на Scheme, а на любом удобном языке. Сейчас выбор основного языка лежит между C++ и Vala.

В теории здесь мог быть и Rust, но программы, написанные на нём, имеют некоторые проблемы с пакетированием, во многом связанные со статической линковкой, общепринятой при работе с этим языком. Это мешает сборке пакетов на сборочницах, не подключенных к интернету.

== Удалённое взаимодействие

На этом можно было бы закончить, но мы не договорили про одну вещь --- удалённое взаимодействие. Как мы можем это делать? Сейчас этот модуль (`remote` для менеджера альтератора) находится на стадии тестирования.

== `alteratorctl`

Мы публикуем бекенды и имеем возможность вызывать их из различных интерфейсов. Почему бы не делать это через консоль? Для такого у нас среди фронтендов есть, наример, замечательный консольный инструмент `alteratorctl`. Здесь мы можем, наример, получить информацию о системе --- ```sh alteratorctl systeminfo arch```. ```sh alteratorctl systeminfo branch``` (версия Альтушки), ```sh alteratorctl systeminfo cpu``` (своего рода neofetch).

`alteratorctl` пока что весьма молодой, поэтому, например, тут пока нет динамической подгрузки модулей.

С помощью флага `--host` как раз можно работать по сети.
